<!DOCTYPE html>
<html>
  <head>
    <title>Bounding Volume Hierachy of pbrt 解析(1) – Wyman的原创技术博客 – 恭喜你发现我的小站，撩我请加QQ：234707482、Wechat：_Wyman</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
    <meta name="baidu-site-verification" content="0OpfO1OtHA" />
    
    <meta name="description" content="二叉树BVH

BVH是空间切分技术之一，除了BVH之外还有kdtree、octree。

下面先以静态场景为例，讲解BVH的生成算法。Note：演示代码是用pbrt源码改的测试版，这是为了理解代码和方便调试。
" />
    <meta property="og:description" content="二叉树BVH

BVH是空间切分技术之一，除了BVH之外还有kdtree、octree。

下面先以静态场景为例，讲解BVH的生成算法。Note：演示代码是用pbrt源码改的测试版，这是为了理解代码和方便调试。
" />
    
    <meta name="author" content="Wyman的原创技术博客" />

    
    <meta property="og:title" content="Bounding Volume Hierachy of pbrt 解析(1)" />
    <meta property="twitter:title" content="Bounding Volume Hierachy of pbrt 解析(1)" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Wyman的原创技术博客 - 恭喜你发现我的小站，撩我请加QQ：234707482、Wechat：_Wyman" href="/feed.xml" />
    
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-65954265-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/bvh-1/',
		  'title': 'Bounding Volume Hierachy of pbrt 解析(1)'
		});
	</script>
	<!-- End Google Analytics -->
	<!-- Baidu Analytics -->
	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?0dc968591d8c64196a37eca9ca4f86b3";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
	<!-- End Baidu Analytics -->

  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://www.qiujiawei.com/images/avatar.jpg" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Wyman的原创技术博客</a></h1>
            <p class="site-description">恭喜你发现我的小站，撩我请加QQ：234707482、Wechat：_Wyman</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <nav class="nav2">
      <ul></ul>
    </nav>

    <div id="main" role="main" class="container">
      <section>  
        <script src="https://code.jquery.com/jquery-3.3.0.min.js" integrity="sha256-RTQy8VOmNlT6b2PIRur37p6JEBZUE7o8wPgMvu18MC4=" crossorigin="anonymous"></script>
<script src="/main.js"></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
<h1>Bounding Volume Hierachy of pbrt 解析(1)</h1>
 <h3>Tags: <a href="/tag/computer-graphics/" rel="tag">computer graphics</a></h3>
<article class="post">
    
    <div class="entry">
        <h2>二叉树BVH</h2>

<p>BVH是空间切分技术之一，除了BVH之外还有kdtree、octree。</p>

<p>下面先以静态场景为例，讲解BVH的生成算法。Note：演示代码是用pbrt源码改的测试版，这是为了理解代码和方便调试。</p>

<!--more-->

<h2>静态场景生成BVH</h2>

<h3>初始化</h3>

<p>首先要确保场景里的3d对象都可以算出它的AABB盒（下面简称BBox）（模型空间），然后经过scene graph以及自身的模型矩阵，把包围盒变换到世界空间，称之为world bound。</p>

<p>代码片段——找出待计算的所有3d对象：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ObjectID</span><span class="o">&gt;</span> <span class="n">objs</span><span class="p">;</span> <span class="c1">// 所有3d对象的id列表</span>
<span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Object</span> <span class="n">objScene</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">filterFunc</span><span class="p">;</span>
<span class="n">filterFunc</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">Object</span> <span class="n">objScene</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">objScene</span><span class="p">.</span><span class="n">hasComponent</span><span class="o">&lt;</span><span class="n">SpatialData</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">objScene</span><span class="p">.</span><span class="n">hasComponent</span><span class="o">&lt;</span><span class="n">MeshRef</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">ObjectID</span> <span class="n">objID</span> <span class="o">=</span> <span class="n">objScene</span><span class="p">.</span><span class="n">ID</span><span class="p">();</span>
        <span class="n">objs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">objID</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">auto</span> <span class="n">sgNode</span> <span class="o">=</span> <span class="n">objScene</span><span class="p">.</span><span class="n">component</span><span class="o">&lt;</span><span class="n">SceneGraphNode</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">childObjID</span> <span class="o">:</span> <span class="n">sgNode</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Object</span> <span class="n">childObj</span> <span class="o">=</span> <span class="n">m_objMgr</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">childObjID</span><span class="p">);</span>
        <span class="n">filterFunc</span><span class="p">(</span><span class="n">childObj</span><span class="p">);</span> <span class="c1">// 树递归</span>
    <span class="p">}</span>
<span class="p">};</span> 
<span class="n">filterFunc</span><span class="p">(</span><span class="n">objScene</span><span class="p">);</span>

</code></pre></div>
<p>代码片段——预先算出所有物体的world bound：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BVHObjInfo</span><span class="o">&gt;</span> <span class="n">objInfo</span><span class="p">(</span><span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">objs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">objs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ObjectID</span> <span class="n">objID</span> <span class="o">=</span> <span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">objs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">m_objMgr</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">objID</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">meshRef</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">component</span><span class="o">&lt;</span><span class="n">MeshRef</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">spatialData</span> <span class="o">=</span> <span class="n">obj</span><span class="p">.</span><span class="n">component</span><span class="o">&lt;</span><span class="n">SpatialData</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">Mesh</span><span class="o">&amp;</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">meshSet</span><span class="o">-&gt;</span><span class="n">getMesh</span><span class="p">(</span><span class="n">meshRef</span><span class="o">-&gt;</span><span class="n">meshID</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">bound</span> <span class="o">=</span> <span class="n">mesh</span><span class="p">.</span><span class="n">Bound</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">worldBound</span> <span class="o">=</span> <span class="p">(</span><span class="n">spatialData</span><span class="o">-&gt;</span><span class="n">o2w</span><span class="p">)(</span><span class="n">bound</span><span class="p">);</span>
    <span class="n">objInfo</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">i</span><span class="p">,</span> <span class="n">worldBound</span> <span class="p">};</span>
<span class="p">}</span>

</code></pre></div>
<p>代码片段——BVH生成流程：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="kt">int</span> <span class="n">totalNodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 统计总共动态创建了多少个BVHBuildNode</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ObjectID</span><span class="o">&gt;</span> <span class="n">orderedObjs</span><span class="p">;</span>
<span class="n">orderedObjs</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">objs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="c1">// 分配空间 </span>
<span class="n">BVHBuildNode</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
<span class="c1">// 2种构造算法，选1</span>
<span class="k">if</span> <span class="p">(</span><span class="n">splitMethod</span> <span class="o">==</span> <span class="n">BVHAccel</span><span class="o">::</span><span class="n">SplitMethod</span><span class="o">::</span><span class="n">HLBVH</span><span class="p">)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">HLBVHBuild</span><span class="p">(</span><span class="n">bvhAccel</span><span class="p">,</span> <span class="n">arena</span><span class="p">,</span> <span class="n">objInfo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">totalNodes</span><span class="p">,</span> <span class="n">orderedObjs</span><span class="p">);</span>
<span class="k">else</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">recursiveBuild</span><span class="p">(</span><span class="n">bvhAccel</span><span class="p">,</span> <span class="n">arena</span><span class="p">,</span> <span class="n">objInfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">objs</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span>
        <span class="o">&amp;</span><span class="n">totalNodes</span><span class="p">,</span> <span class="n">orderedObjs</span><span class="p">);</span>
<span class="c1">// 构造完毕</span>
<span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">objs</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">orderedObjs</span><span class="p">);</span>

<span class="c1">// 计算用深度优先遍历表示的BVH二叉树数组</span>
<span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">AllocAligned</span><span class="o">&lt;</span><span class="n">LinearBVHNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">totalNodes</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">flattenBVHTree</span><span class="p">(</span><span class="n">bvhAccel</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>

</code></pre></div>
<p>可以发现，BVH的核心算法代码就在recursiveBuild和HLBVHBuild里面了。</p>

<h3>相关数据结构</h3>

<p>BVHBuildNode:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// 生成BVH的过程中会用到这个struct，代表BVH的一个节点</span>
<span class="k">struct</span> <span class="n">BVHBuildNode</span> <span class="p">{</span>
    <span class="n">BBox</span> <span class="n">bounds</span><span class="p">;</span> <span class="c1">// 该子树的包围盒 </span>
    <span class="n">BVHBuildNode</span> <span class="o">*</span><span class="n">children</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// 左右孩子节点</span>
    <span class="n">Axis</span> <span class="n">splitAxis</span><span class="p">;</span> <span class="c1">// 是切了哪条坐标轴</span>
    <span class="kt">int</span> <span class="n">firstObjOffset</span><span class="p">,</span> <span class="n">nObjs</span><span class="p">;</span> <span class="c1">// 如果是叶子节点的话，这2个变量记录了被包含的3d物体</span>
<span class="p">};</span>

<span class="c1">// 把node初始化为叶子节点</span>
<span class="kt">void</span> <span class="n">BVHSystem</span><span class="o">::</span><span class="n">InitLeaf</span><span class="p">(</span><span class="n">BVHBuildNode</span> <span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="n">BBox</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">firstObjOffset</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">nObjs</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 把node初始化为内部节点</span>
<span class="kt">void</span> <span class="n">BVHSystem</span><span class="o">::</span><span class="n">InitInterior</span><span class="p">(</span><span class="n">BVHBuildNode</span> <span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="n">Axis</span> <span class="n">axis</span><span class="p">,</span> <span class="n">BVHBuildNode</span> <span class="o">*</span><span class="n">c0</span><span class="p">,</span> <span class="n">BVHBuildNode</span> <span class="o">*</span><span class="n">c1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">c0</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">c1</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">c0</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">,</span> <span class="n">c1</span><span class="o">-&gt;</span><span class="n">bounds</span><span class="p">);</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">splitAxis</span> <span class="o">=</span> <span class="n">axis</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">nObjs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>BVHObjInfo:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">BVHObjInfo</span> <span class="p">{</span>
    <span class="n">BVHObjInfo</span><span class="p">()</span> <span class="p">{}</span>
    <span class="n">BVHObjInfo</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">objNumber</span><span class="p">,</span> <span class="k">const</span> <span class="n">BBox</span> <span class="o">&amp;</span><span class="n">bounds</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">objNumber</span><span class="p">(</span><span class="n">objNumber</span><span class="p">),</span>
        <span class="n">bounds</span><span class="p">(</span><span class="n">bounds</span><span class="p">),</span>
        <span class="n">centroid</span><span class="p">(.</span><span class="mi">5</span><span class="n">f</span> <span class="o">*</span> <span class="n">bounds</span><span class="p">.</span><span class="n">pMin</span> <span class="o">+</span> <span class="p">.</span><span class="mi">5</span><span class="n">f</span> <span class="o">*</span> <span class="n">bounds</span><span class="p">.</span><span class="n">pMax</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">size_t</span> <span class="n">objNumber</span><span class="p">;</span> <span class="c1">// 记录这个3d对象在bvhAccel-&gt;objs数组的位置</span>
    <span class="n">BBox</span> <span class="n">bounds</span><span class="p">;</span>
    <span class="n">Vector3dF</span> <span class="n">centroid</span><span class="p">;</span> <span class="c1">// 包围盒中心坐标</span>
<span class="p">};</span>

</code></pre></div>
<h3>recursiveBuild</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="n">BVHBuildNode</span> <span class="o">*</span><span class="n">BVHSystem</span><span class="o">::</span><span class="n">recursiveBuild</span><span class="p">(</span>
        <span class="n">ComponentHandle</span><span class="o">&lt;</span><span class="n">BVHAccel</span><span class="o">&gt;</span> <span class="n">bvhAccel</span><span class="p">,</span> 
        <span class="n">MemoryArena</span> <span class="o">&amp;</span><span class="n">arena</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">BVHObjInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">,</span> 
        <span class="kt">int</span> <span class="n">start</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> 
        <span class="kt">int</span> <span class="o">*</span><span class="n">totalNodes</span><span class="p">,</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ObjectID</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">orderedObjs</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">BVHBuildNode</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="n">arena</span><span class="p">.</span><span class="n">Alloc</span><span class="o">&lt;</span><span class="n">BVHBuildNode</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="p">(</span><span class="o">*</span><span class="n">totalNodes</span><span class="p">)</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 计数</span>

    <span class="n">BBox</span> <span class="n">bounds</span><span class="p">;</span> <span class="c1">// [start, end) 区间内所有物体的包围盒的并集包围盒</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">bounds</span><span class="p">,</span> <span class="n">objInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bounds</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">nObjs</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span><span class="c1">// [start, end)区间内的物体数量</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nObjs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果只有一个物体，那就把node设置为叶节点</span>
        <span class="kt">int</span> <span class="n">firstObjOffset</span> <span class="o">=</span> <span class="n">orderedObjs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">objNum</span> <span class="o">=</span> <span class="n">objInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">objNumber</span><span class="p">;</span>
            <span class="n">orderedObjs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">objs</span><span class="p">[</span><span class="n">objNum</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">InitLeaf</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">firstObjOffset</span><span class="p">,</span> <span class="n">nObjs</span><span class="p">,</span> <span class="n">bounds</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="err">······</span>
        <span class="c1">// B</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div>
<p>B:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="c1">// 计算[start, end)里的物体包围盒中心坐标的包围盒</span>
<span class="n">BBox</span> <span class="n">centroidBounds</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">centroidBounds</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">centroidBounds</span><span class="p">,</span> <span class="n">objInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">centroid</span><span class="p">);</span>
<span class="c1">//  把边长最长的坐标轴作为切分轴</span>
<span class="n">Axis</span> <span class="n">dim</span> <span class="o">=</span> <span class="n">centroidBounds</span><span class="p">.</span><span class="n">MaximumExtent</span><span class="p">();</span>

<span class="c1">// Partition objs into two sets and build children</span>
<span class="k">if</span> <span class="p">(</span><span class="n">centroidBounds</span><span class="p">.</span><span class="n">pMax</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">==</span> <span class="n">centroidBounds</span><span class="p">.</span><span class="n">pMin</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="p">{</span>
    <span class="c1">// 在边长最长的轴上，竟然pMax和pMin还相等，说明包围盒中心都重叠了，</span>
    <span class="c1">// 把这些物体都归入同个叶子节点</span>
    <span class="kt">int</span> <span class="n">firstObjOffset</span> <span class="o">=</span> <span class="n">orderedObjs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">objNum</span> <span class="o">=</span> <span class="n">objInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">objNumber</span><span class="p">;</span>
        <span class="n">orderedObjs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">objs</span><span class="p">[</span><span class="n">objNum</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">InitLeaf</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">firstObjOffset</span><span class="p">,</span> <span class="n">nObjs</span><span class="p">,</span> <span class="n">bounds</span><span class="p">);</span>
    <span class="c1">// （和上面那段代码一模一样）</span>
    <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="err">······</span>
    <span class="c1">// C</span>
<span class="p">}</span>

</code></pre></div>
<p>到了C，就真的要做<strong>空间切分</strong>了，需要根据SplitMethod选择切分算法。</p>

<p>C:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 默认mid</span>

<span class="c1">// 这个switch的作用就是把[start,end)的物体切分开，并把切分位置记到mid</span>
<span class="c1">// 从而可以对切出来的2个子树继续build</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">splitMethod</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">BVHAccel</span><span class="p">:</span><span class="o">:</span><span class="n">SplitMethod</span><span class="o">::</span><span class="n">Middle</span><span class="o">:</span> <span class="p">{</span> 
        <span class="c1">// 中心切分法</span>
        <span class="c1">// pmid是最长边的边中心点</span>
        <span class="kt">float</span> <span class="n">pmid</span> <span class="o">=</span>
            <span class="p">(</span><span class="n">centroidBounds</span><span class="p">.</span><span class="n">pMin</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">+</span> <span class="n">centroidBounds</span><span class="p">.</span><span class="n">pMax</span><span class="p">[</span><span class="n">dim</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="c1">// 把[start, end)里的物体按pmid切分，小于pmid的在前面</span>
        <span class="c1">// 注意，partition并不是排序</span>
        <span class="n">BVHObjInfo</span> <span class="o">*</span><span class="n">midPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">[</span><span class="n">dim</span><span class="p">,</span> <span class="n">pmid</span><span class="p">](</span><span class="k">const</span> <span class="n">BVHObjInfo</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">pi</span><span class="p">.</span><span class="n">centroid</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pmid</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">midPtr</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="c1">// midPtr指向了pmid右侧第一个对象，然后转成数组下标mid</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">!=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">mid</span> <span class="o">!=</span> <span class="n">end</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="c1">// 如果mid等于start或end，说明这些物体要么都在pmid左侧，要么都在右侧，切分无意义</span>
        <span class="c1">// 所以不能break，继续进入EqualCounts切分</span>
        <span class="c1">// （但按照前面的逻辑来看，这里不应该一个都切分不出来，可能是一个保险措施）</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">BVHAccel</span><span class="p">:</span><span class="o">:</span><span class="n">SplitMethod</span><span class="o">::</span><span class="n">EqualCounts</span><span class="o">:</span> <span class="p">{</span>
        <span class="c1">// 按照数量对半切</span>
        <span class="c1">// nth_element是偏排序，保证比mid小的都排在mid之前，比mid大的都在mid之后，但不保证有序</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span>
            <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">[</span><span class="n">dim</span><span class="p">](</span><span class="k">const</span> <span class="n">BVHObjInfo</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">BVHObjInfo</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">centroid</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">centroid</span><span class="p">[</span><span class="n">dim</span><span class="p">];</span>
        <span class="p">});</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">BVHAccel</span><span class="p">:</span><span class="o">:</span><span class="n">SplitMethod</span><span class="o">::</span><span class="n">SAH</span><span class="o">:</span>
    <span class="nl">default:</span> <span class="p">{</span>
        <span class="err">····</span>
        <span class="c1">// D</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 递归构造子树</span>
<span class="n">InitInterior</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span>
    <span class="n">recursiveBuild</span><span class="p">(</span><span class="n">bvhAccel</span><span class="p">,</span> <span class="n">arena</span><span class="p">,</span> <span class="n">objInfo</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span>
        <span class="n">totalNodes</span><span class="p">,</span> <span class="n">orderedObjs</span><span class="p">),</span>
    <span class="n">recursiveBuild</span><span class="p">(</span><span class="n">bvhAccel</span><span class="p">,</span> <span class="n">arena</span><span class="p">,</span> <span class="n">objInfo</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
        <span class="n">totalNodes</span><span class="p">,</span> <span class="n">orderedObjs</span><span class="p">));</span>

</code></pre></div>
<p>D，是基于概率、表面积的启发式切分法SAH(Surface Area Heuristic)，要用到一条公式：</p>

<p>\[ cost(A, B) = t_{trav} + P_{A} \sum _{i=1}^{N_{A} } t_{isect}(a_{i}) + P_{B} \sum _{i=1}^{N_{B} } t_{isect}(b_{i})  \]</p>

<p>cost(A, B)是ray和这个内部节点做相交计算的时间开销；</p>

<p>\( P_{A} 、 P_{B}\) 分别是ray经过A、B子树的概率；</p>

<p>\( N_{A} 、N_{B}\) 分别是A、B子树的物体的数量；</p>

<p>\( t_{trav} \) 是遍历一个节点的时间开销，\( t_{isect}(a_{i}) 、 t_{isect}(b_{i}) \) 分别是ray和子树某个对象包围盒做相交计算的时间开销。可以简单假设\(t_{trav}、t_{isect}\)都是常数1。那么上式简化成：</p>

<p>\[ cost(A, B) = 1 + P_{A} \sum _{i=1}^{N_{A} } 1  + P_{B} \sum _{i=1}^{N_{B} } 1 =  1 + P_{A} N_{A} + P_{B} N_{B} \]</p>

<p>\( P_{A} 、 P_{B}\) 可以用表面积比来求出：</p>

<p>\[ P_{A} = \frac {S_{A} }{S_{parent } }\]</p>

<p>\[ P_{B} = \frac {S_{B} }{S_{parent } }\]</p>

<p>然后就是应用问题，因为切分的最优位置并不能直接得到，需要对所有可切分点都做这条公式算出cost，然后取那个最小值。</p>

<p>显然这很暴力，所以pbrt作者设计了bucket机制，其实就是把相邻的物体捆绑打包，当作一个整体，再来遍历各个切分点算cost。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="k">if</span> <span class="p">(</span><span class="n">nObjs</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 如果用了SAH但这个节点只有2个物体，就没必要算SAH了，直接切</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">nth_element</span><span class="p">(</span><span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="n">mid</span><span class="p">],</span>
        <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">[</span><span class="n">dim</span><span class="p">](</span><span class="k">const</span> <span class="n">BVHObjInfo</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span>
            <span class="k">const</span> <span class="n">BVHObjInfo</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">centroid</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span> <span class="o">&lt;</span>
            <span class="n">b</span><span class="p">.</span><span class="n">centroid</span><span class="p">[</span><span class="n">dim</span><span class="p">];</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
    <span class="n">constexpr</span> <span class="kt">int</span> <span class="n">nBuckets</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">BucketInfo</span> <span class="n">buckets</span><span class="p">[</span><span class="n">nBuckets</span><span class="p">];</span>

    <span class="c1">// 初始化bucket</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nBuckets</span> <span class="o">*</span>
            <span class="n">centroidBounds</span><span class="p">.</span><span class="n">Offset</span><span class="p">(</span>
                <span class="n">objInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">centroid</span><span class="p">)[</span><span class="n">dim</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">nBuckets</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">Assert</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nBuckets</span><span class="p">);</span>
        <span class="n">buckets</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="n">buckets</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">bounds</span> <span class="o">=</span>
            <span class="n">Union</span><span class="p">(</span><span class="n">buckets</span><span class="p">[</span><span class="n">b</span><span class="p">].</span><span class="n">bounds</span><span class="p">,</span> <span class="n">objInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bounds</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 计算切分开销</span>
    <span class="kt">float</span> <span class="n">cost</span><span class="p">[</span><span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">BBox</span> <span class="n">b0</span><span class="p">,</span> <span class="n">b1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">b0</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">b0</span><span class="p">,</span> <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">bounds</span><span class="p">);</span>
            <span class="n">count0</span> <span class="o">+=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">nBuckets</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">b1</span> <span class="o">=</span> <span class="n">Union</span><span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">bounds</span><span class="p">);</span>
            <span class="n">count1</span> <span class="o">+=</span> <span class="n">buckets</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">count</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span>
            <span class="p">(</span><span class="n">count0</span> <span class="o">*</span> <span class="n">b0</span><span class="p">.</span><span class="n">SurfaceArea</span><span class="p">()</span> <span class="o">+</span>
                <span class="n">count1</span> <span class="o">*</span> <span class="n">b1</span><span class="p">.</span><span class="n">SurfaceArea</span><span class="p">())</span> <span class="o">/</span>
            <span class="n">bounds</span><span class="p">.</span><span class="n">SurfaceArea</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// 线性遍历，找出cost最小的</span>
    <span class="kt">float</span> <span class="n">minCost</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">minCostSplitBucket</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minCost</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">minCost</span> <span class="o">=</span> <span class="n">cost</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">minCostSplitBucket</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">float</span> <span class="n">leafCost</span> <span class="o">=</span> <span class="n">nObjs</span><span class="p">;</span>
    <span class="c1">// 如果数量比maxObjsInNode大 或者 切分开销比直接弄成叶子节点开销小，就做切分</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nObjs</span> <span class="o">&gt;</span> <span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">maxObjsInNode</span> <span class="o">||</span> <span class="n">minCost</span> <span class="o">&lt;</span> <span class="n">leafCost</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">BVHObjInfo</span> <span class="o">*</span><span class="n">pmid</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">partition</span><span class="p">(</span>
            <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">[</span><span class="o">=</span><span class="p">](</span><span class="k">const</span> <span class="n">BVHObjInfo</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nBuckets</span> <span class="o">*</span>
                <span class="n">centroidBounds</span><span class="p">.</span><span class="n">Offset</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">centroid</span><span class="p">)[</span><span class="n">dim</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">nBuckets</span><span class="p">)</span> <span class="n">b</span> <span class="o">=</span> <span class="n">nBuckets</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">Assert</span><span class="p">(</span><span class="n">b</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nBuckets</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">minCostSplitBucket</span><span class="p">;</span>
        <span class="p">});</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">pmid</span> <span class="o">-</span> <span class="o">&amp;</span><span class="n">objInfo</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 否则，弄成叶子节点就行了（这段代码出现第三次了）</span>
        <span class="kt">int</span> <span class="n">firstObjOffset</span> <span class="o">=</span> <span class="n">orderedObjs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">objNum</span> <span class="o">=</span> <span class="n">objInfo</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">objNumber</span><span class="p">;</span>
            <span class="n">orderedObjs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">bvhAccel</span><span class="o">-&gt;</span><span class="n">objs</span><span class="p">[</span><span class="n">objNum</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="n">InitLeaf</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">firstObjOffset</span><span class="p">,</span> <span class="n">nObjs</span><span class="p">,</span> <span class="n">bounds</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div>
    </div>
    <div class="entry">
        (未经授权禁止转载)
    </div>
    <div class="date">
        Written on December 20, 2017
    </div>
    <p>博主将十分感谢对本文章的任意金额的打赏^_^</p>
    <img src="../images/dashang1.jpeg" />
    <img src="../images/dashang2.jpeg" />
    
    
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'qiujiawei';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</article>



      </section>
    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:voyagingmk@gmail.com"><i class="svg-icon email"></i></a>


<a href="http://github.com/barryclark/jekyll-now"><i class="svg-icon github"></i></a>




<a href="http://twitter.com/voyagingmk"><i class="svg-icon twitter"></i></a>


        </footer>
      </div>
    </div>

  </body>
</html>
