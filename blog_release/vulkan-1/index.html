<!DOCTYPE html>
<html>
  <head>
    <title>入门vulkan – Wyman的原创技术博客 – 恭喜你发现我的小站，撩我请加QQ：234707482、Wechat：_Wyman</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
    <meta name="baidu-site-verification" content="0OpfO1OtHA" />
    
    <meta name="description" content="" />
    <meta property="og:description" content="" />
    
    <meta name="author" content="Wyman的原创技术博客" />

    
    <meta property="og:title" content="入门vulkan" />
    <meta property="twitter:title" content="入门vulkan" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Wyman的原创技术博客 - 恭喜你发现我的小站，撩我请加QQ：234707482、Wechat：_Wyman" href="/feed.xml" />
    
	<!-- Google Analytics -->
	<script>
		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

		ga('create', 'UA-65954265-1', 'auto');
		ga('send', 'pageview', {
		  'page': '/vulkan-1/',
		  'title': '入门vulkan'
		});
	</script>
	<!-- End Google Analytics -->
	<!-- Baidu Analytics -->
	<script>
		var _hmt = _hmt || [];
		(function() {
		  var hm = document.createElement("script");
		  hm.src = "//hm.baidu.com/hm.js?0dc968591d8c64196a37eca9ca4f86b3";
		  var s = document.getElementsByTagName("script")[0]; 
		  s.parentNode.insertBefore(hm, s);
		})();
	</script>
	<!-- End Baidu Analytics -->

  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://www.qiujiawei.com/images/avatar.jpg" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Wyman的原创技术博客</a></h1>
            <p class="site-description">恭喜你发现我的小站，撩我请加QQ：234707482、Wechat：_Wyman</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <nav class="nav2">
      <ul></ul>
    </nav>

    <div id="main" role="main" class="container">
      <section>  
        <script src="https://code.jquery.com/jquery-3.3.0.min.js" integrity="sha256-RTQy8VOmNlT6b2PIRur37p6JEBZUE7o8wPgMvu18MC4=" crossorigin="anonymous"></script>
<script src="/main.js"></script>

<h1>入门vulkan</h1>
<h3>Tags: <a href="/tag/vulkan/" rel="tag">vulkan</a></h3>
<article class="post">
  <div class="entry">
    <!--more-->

<h1>安装SDK</h1>

<p>LunarG的SDK、Runtime，以及NVidia的驱动。</p>

<h1>实例</h1>

<h2>LunarG出品的</h2>

<p><a href="https://github.com/LunarG/VulkanSamples">https://github.com/LunarG/VulkanSamples</a></p>

<p>mkdir build
cd build
python ../scripts/update_deps.py --arch Win64
cmake -C helper.cmake -G &quot;Visual Studio 14 2015 Win64&quot; ..
或
cmake -C helper.cmake -G &quot;Visual Studio 15 2017 Win64&quot; ..
cmake --build .</p>

<p>Note：需要python3环境。如果已經有Python2，可以自定义模式安裝python3并取消勾选所有选项（最精简就够了），安装后把path指向python3目录。再执行update_deps.py。最后再改回去python2</p>

<h3>编译问题：</h3>

<p>__std_reverse_trivially_swappable_8：貌似是同时安装VS2015和VS2017才会出现的问题。用cmake -C helper.cmake -G &quot;Visual Studio 15 2017 Win64&quot; .. 试试。</p>

<h2>民间出品的</h2>

<p><a href="https://github.com/SaschaWillems/vulkan">https://github.com/SaschaWillems/vulkan</a></p>

<p>这个不需要安装LunarG的SDK就可以编译运行，很傻瓜化（但应该需要安装新的NVidia驱动）。实质是直接把LunarG的vulkan include目录嵌进去了。</p>

<h1>LunarG draw cube学习笔记</h1>

<p><a href="https://vulkan.lunarg.com/doc/sdk/1.1.92.1/windows/tutorial/html/index.html">https://vulkan.lunarg.com/doc/sdk/1.1.92.1/windows/tutorial/html/index.html</a></p>

<h2>1. 创建必要的VkInstance对象（vkCreateInstance）</h2>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">VkResult</span> <span class="n">VKAPI_CALL</span> <span class="nf">vkCreateInstance</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">VkInstanceCreateInfo</span><span class="o">*</span>                 <span class="n">pCreateInfo</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">VkAllocationCallbacks</span><span class="o">*</span>                <span class="n">pAllocator</span><span class="p">,</span>
    <span class="n">VkInstance</span><span class="o">*</span>                                 <span class="n">pInstance</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">VKAPI_CALL</span> <span class="nf">vkDestroyInstance</span><span class="p">(</span>
    <span class="n">VkInstance</span>                                  <span class="n">instance</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">VkAllocationCallbacks</span><span class="o">*</span>                <span class="n">pAllocator</span><span class="p">);</span>
</code></pre></div>
<p>给定pCreateInfo对象，可以创建VkInstance对象（放在pInstance返回），要通过VkResult检查是否正确创建。</p>

<h2>2. 枚举设备enumerate_devices（vkEnumeratePhysicalDevices）</h2>

<p>这一步是确定本机有什么物理设备（GPU），写入到VkPhysicalDevice数组里。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">VkInstance</span>  <span class="n">inst</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkPhysicalDevice</span><span class="o">&gt;</span> <span class="n">gpus</span><span class="p">;</span>
    <span class="err">···</span>
    <span class="kt">uint32_t</span> <span class="n">gpu_count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">VkResult</span> <span class="n">U_ASSERT_ONLY</span> <span class="n">res</span> <span class="o">=</span> <span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpu_count</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">gpu_count</span><span class="p">);</span>
    <span class="n">gpus</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">gpu_count</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">vkEnumeratePhysicalDevices</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">gpu_count</span><span class="p">,</span> <span class="n">gpus</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">res</span> <span class="o">&amp;&amp;</span> <span class="n">gpu_count</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>vkEnumeratePhysicalDevices同一个接口用两次，第一次的第三个参数设NULL，可以获取gpu数量；知道gpu数量后，第二次传入一个raw的VkPhysicalDevice数组指针，直接让api初始化这个数组。</p>

<p>因为是raw的数组指针，所以要先resize这个vector，确保有足够的空间放数据。</p>

<h2>3. 创建一个（逻辑）设备对象 vkCreateDevice</h2>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="kt">uint32_t</span> <span class="n">queue_family_count</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">VkQueueFamilyProperties</span><span class="o">&gt;</span> <span class="n">queue_props</span><span class="p">;</span>

    <span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">queue_family_count</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">queue_props</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">queue_family_count</span><span class="p">);</span>
    <span class="n">vkGetPhysicalDeviceQueueFamilyProperties</span><span class="p">(</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">queue_family_count</span><span class="p">,</span> <span class="n">queue_props</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">queue_family_count</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">);</span>
</code></pre></div>
<p>vkGetPhysicalDeviceQueueFamilyProperties的用法和vkEnumeratePhysicalDevices非常相似。</p>

<p>vkGetPhysicalDeviceQueueFamilyProperties的用途是获取这个gpu的queue_family_count和queue_props。queue_props则是一个VkQueueFamilyProperties数组。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkQueueFamilyProperties</span> <span class="p">{</span>
    <span class="n">VkQueueFlags</span>    <span class="n">queueFlags</span><span class="p">;</span>
    <span class="kt">uint32_t</span>        <span class="n">queueCount</span><span class="p">;</span>
    <span class="kt">uint32_t</span>        <span class="n">timestampValidBits</span><span class="p">;</span>
    <span class="n">VkExtent3D</span>      <span class="n">minImageTransferGranularity</span><span class="p">;</span>
<span class="p">}</span> <span class="n">VkQueueFamilyProperties</span><span class="p">;</span>
</code></pre></div>
<p>注意这个是family，每个family里可以有多个queue，queue的数量看queueCount。每个family对应多个flags集合：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">enum</span> <span class="n">VkQueueFlagBits</span> <span class="p">{</span>
    <span class="n">VK_QUEUE_GRAPHICS_BIT</span> <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span>
    <span class="n">VK_QUEUE_COMPUTE_BIT</span> <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span>
    <span class="n">VK_QUEUE_TRANSFER_BIT</span> <span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span>
    <span class="n">VK_QUEUE_SPARSE_BINDING_BIT</span> <span class="o">=</span> <span class="mh">0x00000008</span><span class="p">,</span>
    <span class="n">VK_QUEUE_PROTECTED_BIT</span> <span class="o">=</span> <span class="mh">0x00000010</span><span class="p">,</span>
    <span class="n">VK_QUEUE_FLAG_BITS_MAX_ENUM</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
<span class="p">}</span> <span class="n">VkQueueFlagBits</span><span class="p">;</span>
</code></pre></div>
<p>例如一般第一个family的flags是15，即VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT | VK_QUEUE_TRANSFER_BIT | VK_QUEUE_SPARSE_BINDING_BIT。</p>

<p>queue_family_count和queue_props有了后，就可以创建device了。创建device的接口是vkCreateDevice。</p>

<p>在调用这个接口前需要准备好VkDeviceQueueCreateInfo对象、VkDeviceCreateInfo对象。</p>

<p>VkDeviceQueueCreateInfo对象：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="n">VkDeviceQueueCreateInfo</span> <span class="n">queue_info</span> <span class="o">=</span> <span class="p">{};</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">queue_family_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">queue_props</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queueFlags</span> <span class="o">&amp;</span> <span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">queue_info</span><span class="p">.</span><span class="n">queueFamilyIndex</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">float</span> <span class="n">queue_priorities</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">};</span>
<span class="n">queue_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO</span><span class="p">;</span>
<span class="n">queue_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">queue_info</span><span class="p">.</span><span class="n">queueCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">queue_info</span><span class="p">.</span><span class="n">pQueuePriorities</span> <span class="o">=</span> <span class="n">queue_priorities</span><span class="p">;</span>

</code></pre></div>
<p>VkDeviceCreateInfo对象：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">
<span class="n">VkDeviceCreateInfo</span> <span class="n">device_info</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">queueCreateInfoCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">pQueueCreateInfos</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">queue_info</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">enabledExtensionCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">ppEnabledExtensionNames</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">enabledLayerCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">ppEnabledLayerNames</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">device_info</span><span class="p">.</span><span class="n">pEnabledFeatures</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>
<p>然后就：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">VkDevice</span> <span class="n">device</span><span class="p">;</span>
    <span class="n">VkResult</span> <span class="n">U_ASSERT_ONLY</span> <span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateDevice</span><span class="p">(</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">device_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">device</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>

    <span class="n">vkDestroyDevice</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></div>
<h2>4. 创建VkCommandPool和VkCommandBuffer</h2>

<p>vkCreateCommandPool创建池，vkAllocateCommandBuffers则从池里分配buffer：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">VkDevice</span> <span class="n">device</span><span class="p">;</span>
    <span class="n">VkCommandPool</span> <span class="n">cmd_pool</span><span class="p">;</span>
    <span class="n">VkCommandBuffer</span> <span class="n">cmd</span><span class="p">;</span>

    <span class="n">VkCommandPoolCreateInfo</span> <span class="n">cmd_pool_create_info</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">cmd_pool_create_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO</span><span class="p">;</span>
    <span class="n">cmd_pool_create_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">cmd_pool_create_info</span><span class="p">.</span><span class="n">queueFamilyIndex</span> <span class="o">=</span> <span class="n">graphics_queue_family_index</span><span class="p">;</span> <span class="c1">// 上一步的</span>
    <span class="n">cmd_pool_create_info</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateCommandPool</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd_pool_create_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd_pool</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>

    <span class="cm">/* Create the command buffer from the command pool */</span>
    <span class="n">VkCommandBufferAllocateInfo</span> <span class="n">cmd_buffer_alloc_info</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">cmd_buffer_alloc_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO</span><span class="p">;</span>
    <span class="n">cmd_buffer_alloc_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">cmd_buffer_alloc_info</span><span class="p">.</span><span class="n">commandPool</span> <span class="o">=</span> <span class="n">cmd_pool</span><span class="p">;</span>
    <span class="n">cmd_buffer_alloc_info</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">VK_COMMAND_BUFFER_LEVEL_PRIMARY</span><span class="p">;</span>
    <span class="n">cmd_buffer_alloc_info</span><span class="p">.</span><span class="n">commandBufferCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">vkAllocateCommandBuffers</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd_buffer_alloc_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>
</code></pre></div>
<h2>5. swapchain</h2>

<h3>extension</h3>

<p>首先要在创建instance之前插个步骤，设置instance_extension_names：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">init_instance_extension_names</span><span class="p">(</span><span class="k">struct</span> <span class="n">sample_info</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">info</span><span class="p">.</span><span class="n">instance_extension_names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">VK_KHR_SURFACE_EXTENSION_NAME</span><span class="p">);</span>
<span class="cp">#ifdef __ANDROID__
</span>    <span class="n">info</span><span class="p">.</span><span class="n">instance_extension_names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">VK_KHR_ANDROID_SURFACE_EXTENSION_NAME</span><span class="p">);</span>
<span class="cp">#elif defined(_WIN32)
</span>    <span class="n">info</span><span class="p">.</span><span class="n">instance_extension_names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">VK_KHR_WIN32_SURFACE_EXTENSION_NAME</span><span class="p">);</span>
<span class="cp">#elif defined(VK_USE_PLATFORM_IOS_MVK)
</span>    <span class="n">info</span><span class="p">.</span><span class="n">instance_extension_names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">VK_MVK_IOS_SURFACE_EXTENSION_NAME</span><span class="p">);</span>
<span class="cp">#elif defined(VK_USE_PLATFORM_MACOS_MVK)
</span>    <span class="n">info</span><span class="p">.</span><span class="n">instance_extension_names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">VK_MVK_MACOS_SURFACE_EXTENSION_NAME</span><span class="p">);</span>
<span class="cp">#elif defined(VK_USE_PLATFORM_WAYLAND_KHR)
</span>    <span class="n">info</span><span class="p">.</span><span class="n">instance_extension_names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME</span><span class="p">);</span>
<span class="cp">#else
</span>    <span class="n">info</span><span class="p">.</span><span class="n">instance_extension_names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">VK_KHR_XCB_SURFACE_EXTENSION_NAME</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="p">}</span>
</code></pre></div>
<p>还有device的extension：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">init_device_extension_names</span><span class="p">(</span><span class="k">struct</span> <span class="n">sample_info</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">info</span><span class="p">.</span><span class="n">device_extension_names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">VK_KHR_SWAPCHAIN_EXTENSION_NAME</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<p>swapchain的解释：就是一系列image buffer，gpu会往里面绘制东西，这些buffer可显示到硬件。</p>

<p>正因为是由硬件来绘制，所以才需要一个device级别的扩展，才能使得swapchain工作。</p>

<h3>pSupportsPresent</h3>

<p>先是查出有多少queue支持presenting，总共要遍历queue_family_count次：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="c1">// Iterate over each queue to learn whether it supports presenting:</span>
    <span class="n">VkBool32</span> <span class="o">*</span><span class="n">pSupportsPresent</span> <span class="o">=</span> <span class="p">(</span><span class="n">VkBool32</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">queue_family_count</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">VkBool32</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">queue_family_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vkGetPhysicalDeviceSurfaceSupportKHR</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">surface</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pSupportsPresent</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
</code></pre></div>
<p>有了pSupportsPresent布尔数组后，就遍历下看看哪个queue可以作为graphics queue、present queue ：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// Search for a graphics and a present queue in the array of queue</span>
<span class="c1">// families, try to find one that supports both</span>
<span class="n">info</span><span class="p">.</span><span class="n">graphics_queue_family_index</span> <span class="o">=</span> <span class="n">UINT32_MAX</span><span class="p">;</span>
<span class="n">info</span><span class="p">.</span><span class="n">present_queue_family_index</span> <span class="o">=</span> <span class="n">UINT32_MAX</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">queue_family_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 前提得支持Graphics，再看pSupportsPresent</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="p">.</span><span class="n">queue_props</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queueFlags</span> <span class="o">&amp;</span> <span class="n">VK_QUEUE_GRAPHICS_BIT</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">graphics_queue_family_index</span> <span class="o">==</span> <span class="n">UINT32_MAX</span><span class="p">)</span>
            <span class="n">info</span><span class="p">.</span><span class="n">graphics_queue_family_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">pSupportsPresent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">VK_TRUE</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">info</span><span class="p">.</span><span class="n">graphics_queue_family_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">info</span><span class="p">.</span><span class="n">present_queue_family_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>
<p>有可能找不到合适的present_queue_family_index（也意味着没有同时支持graphics和present的queue），则随便找一个pSupportsPresent[i]为VK_TRUE的queue，即让graphic queue和present queue分离：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">present_queue_family_index</span> <span class="o">==</span> <span class="n">UINT32_MAX</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If didn't find a queue that supports both graphics and present, then</span>
    <span class="c1">// find a separate present queue.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">queue_family_count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pSupportsPresent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">VK_TRUE</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">info</span><span class="p">.</span><span class="n">present_queue_family_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 此时可以释放pSupportsPresent了</span>
<span class="n">free</span><span class="p">(</span><span class="n">pSupportsPresent</span><span class="p">);</span>
</code></pre></div>
<h3>创建surface</h3>

<p>这里用到了2个参数info.connection、info.window，暂时跳过；vkCreateWin32SurfaceKHR创建一个surface并放进info.surface：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">VkWin32SurfaceCreateInfoKHR</span> <span class="n">createInfo</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">createInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR</span><span class="p">;</span>
    <span class="n">createInfo</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">createInfo</span><span class="p">.</span><span class="n">hinstance</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">connection</span><span class="p">;</span>
    <span class="n">createInfo</span><span class="p">.</span><span class="n">hwnd</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">window</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateWin32SurfaceKHR</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">inst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">createInfo</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">surface</span><span class="p">);</span>
</code></pre></div>
<h3>初始化 VkSwapchainCreateInfoKHR</h3>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">VkSwapchainCreateInfoKHR</span> <span class="n">swapchain_ci</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">surface</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">surface</span><span class="p">;</span> <span class="c1">// 上一节刚创建的</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">minImageCount</span> <span class="o">=</span> <span class="n">desiredNumberOfSwapChainImages</span><span class="p">;</span> <span class="c1">// 调用vkGetPhysicalDeviceSurfaceCapabilitiesKHR接口得到，VkSurfaceCapabilitiesKHR结构里存放这些信息</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">imageFormat</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">format</span><span class="p">;</span> <span class="c1">// 调用vkGetPhysicalDeviceSurfaceFormatsKHR接口得到</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">imageExtent</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">swapchainExtent</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">imageExtent</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">swapchainExtent</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">preTransform</span> <span class="o">=</span> <span class="n">preTransform</span><span class="p">;</span> <span class="c1">// VkSurfaceTransformFlagBitsKHR， 调用vkGetPhysicalDeviceSurfaceCapabilitiesKHR接口得到</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">compositeAlpha</span> <span class="o">=</span> <span class="n">compositeAlpha</span><span class="p">;</span><span class="c1">// 一般是VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">imageArrayLayers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">presentMode</span> <span class="o">=</span> <span class="n">swapchainPresentMode</span><span class="p">;</span> <span class="c1">// 写死的VK_PRESENT_MODE_FIFO_KHR</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">oldSwapchain</span> <span class="o">=</span> <span class="n">VK_NULL_HANDLE</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">clipped</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">imageColorSpace</span> <span class="o">=</span> <span class="n">VK_COLORSPACE_SRGB_NONLINEAR_KHR</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">imageUsage</span> <span class="o">=</span> <span class="n">VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">imageSharingMode</span> <span class="o">=</span> <span class="n">VK_SHARING_MODE_EXCLUSIVE</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">queueFamilyIndexCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">pQueueFamilyIndices</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">uint32_t</span> <span class="n">queueFamilyIndices</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">info</span><span class="p">.</span><span class="n">graphics_queue_family_index</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="n">info</span><span class="p">.</span><span class="n">present_queue_family_index</span><span class="p">};</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">graphics_queue_family_index</span> <span class="o">!=</span> <span class="n">info</span><span class="p">.</span><span class="n">present_queue_family_index</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// If the graphics and present queues are from different queue families,</span>
        <span class="c1">// we either have to explicitly transfer ownership of images between</span>
        <span class="c1">// the queues, or we have to create the swapchain with imageSharingMode</span>
        <span class="c1">// as VK_SHARING_MODE_CONCURRENT</span>
        <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">imageSharingMode</span> <span class="o">=</span> <span class="n">VK_SHARING_MODE_CONCURRENT</span><span class="p">;</span>
        <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">queueFamilyIndexCount</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">swapchain_ci</span><span class="p">.</span><span class="n">pQueueFamilyIndices</span> <span class="o">=</span> <span class="n">queueFamilyIndices</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div>
<p>准备了一大堆的信息，然后就可以调用vkCreateSwapchainKHR:</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateSwapchainKHR</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">swapchain_ci</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">swap_chain</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>
</code></pre></div>
<p>这个操作创建了一个images集合，组成了swapchain。</p>

<p>有了swapchain对象后，就可以取出swapchainImages对象，很经典的先获得count再获得指针的操作：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">res</span> <span class="o">=</span> <span class="n">vkGetSwapchainImagesKHR</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">swap_chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">swapchainImageCount</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>

    <span class="n">VkImage</span> <span class="o">*</span><span class="n">swapchainImages</span> <span class="o">=</span> <span class="p">(</span><span class="n">VkImage</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">swapchainImageCount</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="n">VkImage</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">swapchainImages</span><span class="p">);</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">vkGetSwapchainImagesKHR</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">swap_chain</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">swapchainImageCount</span><span class="p">,</span> <span class="n">swapchainImages</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>
</code></pre></div>
<h3>image view</h3>

<p>image view大概意思是用来管理image的内存的，有很多关于image的元信息。</p>

<p>创建image view就比较直白了：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_swap_chain_buffers</span> <span class="p">{</span>
    <span class="n">VkImage</span> <span class="n">image</span><span class="p">;</span>
    <span class="n">VkImageView</span> <span class="n">view</span><span class="p">;</span>
<span class="p">}</span> <span class="n">swap_chain_buffer</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">swap_chain_buffer</span><span class="o">&gt;</span> <span class="n">buffers</span><span class="p">;</span>
<span class="err">···</span>

<span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">swapchainImageCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">VkImageViewCreateInfo</span> <span class="n">color_image_view</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">image</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">viewType</span> <span class="o">=</span> <span class="n">VK_IMAGE_VIEW_TYPE_2D</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">format</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">VK_COMPONENT_SWIZZLE_R</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">VK_COMPONENT_SWIZZLE_G</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">VK_COMPONENT_SWIZZLE_B</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">VK_COMPONENT_SWIZZLE_A</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">subresourceRange</span><span class="p">.</span><span class="n">aspectMask</span> <span class="o">=</span> <span class="n">VK_IMAGE_ASPECT_COLOR_BIT</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">subresourceRange</span><span class="p">.</span><span class="n">baseMipLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">subresourceRange</span><span class="p">.</span><span class="n">levelCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">subresourceRange</span><span class="p">.</span><span class="n">baseArrayLayer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">color_image_view</span><span class="p">.</span><span class="n">subresourceRange</span><span class="p">.</span><span class="n">layerCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateImageView</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">color_image_view</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">view</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>
<span class="err">···</span>
<span class="cm">/* Clean Up */</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="p">.</span><span class="n">swapchainImageCount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vkDestroyImageView</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">buffers</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">view</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>
<h2>6. 深度缓冲区depth buffer（VkImage）</h2>

<p>首先depth buffer是可选的。但是做实时3D渲染都会用到depth buffer，所以必须学习。</p>

<p>depth buffer只需要一个，即使swapchain有多个image。</p>

<p>depth buffer总的创建步骤是：</p>

<ol>
<li>创建depth buffer 图像对象(image object)</li>
<li>分配depth buffer 设备内存(device memory)</li>
<li>把这块内存绑定到image object</li>
<li>创建depth buffer image view</li>
</ol>

<p>首先查询VK_FORMAT_D16_UNORM是否支持：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="k">const</span> <span class="n">VkFormat</span> <span class="n">depth_format</span> <span class="o">=</span> <span class="n">VK_FORMAT_D16_UNORM</span><span class="p">;</span>
    <span class="n">VkFormatProperties</span> <span class="n">props</span><span class="p">;</span>
    <span class="n">vkGetPhysicalDeviceFormatProperties</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">gpus</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">depth_format</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">props</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">props</span><span class="p">.</span><span class="n">linearTilingFeatures</span> <span class="o">&amp;</span> <span class="n">VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">image_info</span><span class="p">.</span><span class="n">tiling</span> <span class="o">=</span> <span class="n">VK_IMAGE_TILING_LINEAR</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">props</span><span class="p">.</span><span class="n">optimalTilingFeatures</span> <span class="o">&amp;</span> <span class="n">VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">image_info</span><span class="p">.</span><span class="n">tiling</span> <span class="o">=</span> <span class="n">VK_IMAGE_TILING_OPTIMAL</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="cm">/* Try other depth formats? */</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"VK_FORMAT_D16_UNORM Unsupported.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">exit</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div>
<p>创建depth buffer：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="p">{</span>
    <span class="n">VkImageCreateInfo</span> <span class="n">image_info</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">imageType</span> <span class="o">=</span> <span class="n">VK_IMAGE_TYPE_2D</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">depth_format</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">extent</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">extent</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">extent</span><span class="p">.</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">mipLevels</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">arrayLayers</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">samples</span> <span class="o">=</span> <span class="n">NUM_SAMPLES</span><span class="p">;</span> <span class="c1">// 1</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">initialLayout</span> <span class="o">=</span> <span class="n">VK_IMAGE_LAYOUT_UNDEFINED</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">usage</span> <span class="o">=</span> <span class="n">VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">queueFamilyIndexCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">pQueueFamilyIndices</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">sharingMode</span> <span class="o">=</span> <span class="n">VK_SHARING_MODE_EXCLUSIVE</span><span class="p">;</span>
    <span class="n">image_info</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">info</span><span class="p">.</span><span class="n">depth</span><span class="p">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">depth_format</span><span class="p">;</span>

    <span class="cm">/* Create image */</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateImage</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">image_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">depth</span><span class="p">.</span><span class="n">image</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//其中info.depth为：</span>
<span class="k">struct</span> <span class="p">{</span>
    <span class="n">VkFormat</span> <span class="n">format</span><span class="p">;</span>

    <span class="n">VkImage</span> <span class="n">image</span><span class="p">;</span>
    <span class="n">VkDeviceMemory</span> <span class="n">mem</span><span class="p">;</span>
    <span class="n">VkImageView</span> <span class="n">view</span><span class="p">;</span>
<span class="p">}</span> <span class="n">depth</span><span class="p">;</span>
</code></pre></div>
<p>这样就完成了第一步创建depth buffer对象。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="c1">// 等下给vkAllocateMemory用的参数</span>
<span class="n">VkMemoryAllocateInfo</span> <span class="n">mem_alloc</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">mem_alloc</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</span><span class="p">;</span>
<span class="n">mem_alloc</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">mem_alloc</span><span class="p">.</span><span class="n">allocationSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">mem_alloc</span><span class="p">.</span><span class="n">memoryTypeIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">VkMemoryRequirements</span> <span class="n">mem_reqs</span><span class="p">;</span>

<span class="n">vkGetImageMemoryRequirements</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">depth</span><span class="p">.</span><span class="n">image</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mem_reqs</span><span class="p">);</span>

<span class="n">mem_alloc</span><span class="p">.</span><span class="n">allocationSize</span> <span class="o">=</span> <span class="n">mem_reqs</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
<span class="c1">// 根据mem_reqs的信息，决定内存类型</span>
<span class="n">pass</span> <span class="o">=</span>
    <span class="n">memory_type_from_properties</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">mem_reqs</span><span class="p">.</span><span class="n">memoryTypeBits</span><span class="p">,</span> <span class="n">VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mem_alloc</span><span class="p">.</span><span class="n">memoryTypeIndex</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">pass</span><span class="p">);</span>

<span class="c1">// 2. 分配内存 放进VkDeviceMemory对象info.depth.mem</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">vkAllocateMemory</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mem_alloc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">depth</span><span class="p">.</span><span class="n">mem</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>

<span class="c1">// 3. 把内存绑定给info.depth.image对象</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">vkBindImageMemory</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">depth</span><span class="p">.</span><span class="n">image</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">depth</span><span class="p">.</span><span class="n">mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>
</code></pre></div>
<p>最后一步创建image view ：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="n">VkImageViewCreateInfo</span> <span class="n">view_info</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">VK_NULL_HANDLE</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">depth_format</span><span class="p">;</span><span class="c1">// VK_FORMAT_D16_UNORM</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">VK_COMPONENT_SWIZZLE_R</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">VK_COMPONENT_SWIZZLE_G</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">VK_COMPONENT_SWIZZLE_B</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">VK_COMPONENT_SWIZZLE_A</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">subresourceRange</span><span class="p">.</span><span class="n">aspectMask</span> <span class="o">=</span> <span class="n">VK_IMAGE_ASPECT_DEPTH_BIT</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">subresourceRange</span><span class="p">.</span><span class="n">baseMipLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">subresourceRange</span><span class="p">.</span><span class="n">levelCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">subresourceRange</span><span class="p">.</span><span class="n">baseArrayLayer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">subresourceRange</span><span class="p">.</span><span class="n">layerCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">viewType</span> <span class="o">=</span> <span class="n">VK_IMAGE_VIEW_TYPE_2D</span><span class="p">;</span>
<span class="n">view_info</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// 4. 创建image view </span>
<span class="n">view_info</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">depth</span><span class="p">.</span><span class="n">image</span><span class="p">;</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateImageView</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">view_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">depth</span><span class="p">.</span><span class="n">view</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>
</code></pre></div>
<h2>7. Uniform Buffer (VkBuffer)</h2>

<p>这个uniform buffer的uniform，就是指glsl的uniform，同个东西。glsl只需要调用api直接set uniform即可，而vulkan则需要自己分配内存并填充数据来实现。</p>

<p>三个步骤：</p>

<ol>
<li>Creating the Uniform Buffer Object</li>
<li>Allocating the Uniform Buffer Memory</li>
<li>Mapping and Setting the Uniform Buffer Memory</li>
</ol>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="p">{</span>
    <span class="n">VkBuffer</span> <span class="n">buf</span><span class="p">;</span>
    <span class="n">VkDeviceMemory</span> <span class="n">mem</span><span class="p">;</span>
    <span class="n">VkDescriptorBufferInfo</span> <span class="n">buffer_info</span><span class="p">;</span>
<span class="p">}</span> <span class="n">uniform_data</span><span class="p">;</span>

<span class="err">···</span>

<span class="cm">/* VULKAN_KEY_START */</span>
<span class="n">VkBufferCreateInfo</span> <span class="n">buf_info</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">buf_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO</span><span class="p">;</span>
<span class="n">buf_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">buf_info</span><span class="p">.</span><span class="n">usage</span> <span class="o">=</span> <span class="n">VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT</span><span class="p">;</span>
<span class="n">buf_info</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">MVP</span><span class="p">);</span>
<span class="n">buf_info</span><span class="p">.</span><span class="n">queueFamilyIndexCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">buf_info</span><span class="p">.</span><span class="n">pQueueFamilyIndices</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">buf_info</span><span class="p">.</span><span class="n">sharingMode</span> <span class="o">=</span> <span class="n">VK_SHARING_MODE_EXCLUSIVE</span><span class="p">;</span>
<span class="n">buf_info</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateBuffer</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">buf</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>
</code></pre></div>
<p>然后分配内存，和depth buffer的时候几乎一样：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c">    <span class="n">VkMemoryRequirements</span> <span class="n">mem_reqs</span><span class="p">;</span>
    <span class="n">vkGetBufferMemoryRequirements</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mem_reqs</span><span class="p">);</span>

    <span class="n">VkMemoryAllocateInfo</span> <span class="n">alloc_info</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">alloc_info</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO</span><span class="p">;</span>
    <span class="n">alloc_info</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">alloc_info</span><span class="p">.</span><span class="n">memoryTypeIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">alloc_info</span><span class="p">.</span><span class="n">allocationSize</span> <span class="o">=</span> <span class="n">mem_reqs</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
    <span class="n">pass</span> <span class="o">=</span> <span class="n">memory_type_from_properties</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">mem_reqs</span><span class="p">.</span><span class="n">memoryTypeBits</span><span class="p">,</span>
                                       <span class="n">VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT</span> <span class="o">|</span> <span class="n">VK_MEMORY_PROPERTY_HOST_COHERENT_BIT</span><span class="p">,</span>
                                       <span class="o">&amp;</span><span class="n">alloc_info</span><span class="p">.</span><span class="n">memoryTypeIndex</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">pass</span> <span class="o">&amp;&amp;</span> <span class="s">"No mappable, coherent memory"</span><span class="p">);</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">vkAllocateMemory</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alloc_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">mem</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>
</code></pre></div>
<p>VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT是让CPU（host）可以访问这块内存；The VK_MEMORY_PROPERTY_HOST_COHERENT_BIT 则让CPU写内存对设备可见且不需要刷内存缓存。所以只是一个便捷设置，避免调用vkFlushMappedMemoryRanges、vkInvalidateMappedMemoryRanges，确保数据对GPU可见。</p>

<p>最后vkMapMemory：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pData</span><span class="p">;</span>
<span class="c1">// info.uniform_data.mem已经由vkAllocateMemory分配了</span>
<span class="c1">// pData转2维数组指针骚操作</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">vkMapMemory</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mem_reqs</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pData</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>

<span class="c1">// 把MVP矩阵复制到映射内存</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">pData</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">MVP</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">MVP</span><span class="p">));</span>

<span class="c1">// 解除映射关系</span>
<span class="n">vkUnmapMemory</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">mem</span><span class="p">);</span>

<span class="c1">// 然后绑定内存给uniform buffer</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">vkBindBufferMemory</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">buf</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>

<span class="c1">// 设置VkDescriptorBufferInfo</span>
<span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">buffer_info</span><span class="p">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">buf</span><span class="p">;</span>
<span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">buffer_info</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">info</span><span class="p">.</span><span class="n">uniform_data</span><span class="p">.</span><span class="n">buffer_info</span><span class="p">.</span><span class="n">range</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">MVP</span><span class="p">);</span> <span class="c1">// 在这里确定了内存范围</span>
</code></pre></div>
<p>buffer_info结构：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">VkDescriptorBufferInfo</span> <span class="p">{</span>
    <span class="n">VkBuffer</span>        <span class="n">buffer</span><span class="p">;</span>
    <span class="n">VkDeviceSize</span>    <span class="n">offset</span><span class="p">;</span>
    <span class="n">VkDeviceSize</span>    <span class="n">range</span><span class="p">;</span>
<span class="p">}</span> <span class="n">VkDescriptorBufferInfo</span><span class="p">;</span>
</code></pre></div>
<h2>8. descriptor、Descriptor Sets、Descriptor Set Layouts、 Pipeline Layouts</h2>

<h3>descriptor</h3>

<p>上一节的uniform buffer只是做到了内存的处理，还没涉及到怎么使用uniform buffer。里面存了MVP矩阵信息，是要给vertex shader用的。接下来介绍怎么做，要用到一个新的东西叫descriptor。</p>

<p>一个descriptor是一个特别的shader变量，shader可以用它来访问buffer和image资源，因此它像是一个指向资源的指针。Vulkan API允许在draw操作之间改变这些变量，使得shader可以在不同的draw里访问不同的资源。</p>

<p>一个descriptor可以绑定一个放着mvp矩阵的uniform buffer，也可以创建多个uniform buffer，然后切换绑定不同的uniform buffer实现不同的视角转换。</p>

<p>虽然目前为止还没用到textures，不过descriptor的一个用法是，用多个descriptor来引用不同的纹理，在单次draw里这些纹理同时可用。</p>

<h3>descriptor set</h3>

<p>descriptor set的创建在下节介绍，这里只是介绍用法。</p>

<h3>descriptor set layout</h3>

<p>为了描述一个descriptor set，得用一个descriptor set layout。</p>

<p>A descriptor set layout可以描述多个descriptor sets的内容。同时，每一个descriptor set也需要自己的layout。</p>

<p>先是准备好VkDescriptorSetLayoutBinding对象：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* Number of descriptor sets needs to be the same at alloc,       */</span>
<span class="cm">/* pipeline layout creation, and descriptor set layout creation   */</span>
<span class="cp">#define NUM_DESCRIPTOR_SETS 1
</span>
<span class="n">VkDescriptorSetLayoutBinding</span> <span class="n">layout_binding</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">layout_binding</span><span class="p">.</span><span class="n">binding</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 索引0？</span>
<span class="n">layout_binding</span><span class="p">.</span><span class="n">descriptorType</span> <span class="o">=</span> <span class="n">VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER</span><span class="p">;</span> <span class="c1">// uniform buffer</span>
<span class="n">layout_binding</span><span class="p">.</span><span class="n">descriptorCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// descriptor set里只有一个descriptor</span>
<span class="n">layout_binding</span><span class="p">.</span><span class="n">stageFlags</span> <span class="o">=</span> <span class="n">VK_SHADER_STAGE_VERTEX_BIT</span><span class="p">;</span><span class="c1">// vertex shader阶段使用</span>
<span class="n">layout_binding</span><span class="p">.</span><span class="n">pImmutableSamplers</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</code></pre></div>
<p>然后就可以初始化std::vector<VkDescriptorSetLayout> desc_layout了：</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* Next take layout bindings and use them to create a descriptor set layout
    */</span>
<span class="n">VkDescriptorSetLayoutCreateInfo</span> <span class="n">descriptor_layout</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">descriptor_layout</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO</span><span class="p">;</span>
<span class="n">descriptor_layout</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">descriptor_layout</span><span class="p">.</span><span class="n">bindingCount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">descriptor_layout</span><span class="p">.</span><span class="n">pBindings</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">layout_binding</span><span class="p">;</span>

<span class="n">info</span><span class="p">.</span><span class="n">desc_layout</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="n">NUM_DESCRIPTOR_SETS</span><span class="p">);</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">vkCreateDescriptorSetLayout</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">descriptor_layout</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">desc_layout</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
<span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>
</code></pre></div>
<h3>Pipeline Layouts</h3>

<p>一个pipeline layout包含1到多个descriptor set layout。</p>
<div class="highlight"><pre><code class="language-c" data-lang="c"><span class="cm">/* Now use the descriptor layout to create a pipeline layout */</span>
<span class="n">VkPipelineLayoutCreateInfo</span> <span class="n">pPipelineLayoutCreateInfo</span> <span class="o">=</span> <span class="p">{};</span>
<span class="n">pPipelineLayoutCreateInfo</span><span class="p">.</span><span class="n">sType</span> <span class="o">=</span> <span class="n">VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO</span><span class="p">;</span>
<span class="n">pPipelineLayoutCreateInfo</span><span class="p">.</span><span class="n">pNext</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">pPipelineLayoutCreateInfo</span><span class="p">.</span><span class="n">pushConstantRangeCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pPipelineLayoutCreateInfo</span><span class="p">.</span><span class="n">pPushConstantRanges</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">pPipelineLayoutCreateInfo</span><span class="p">.</span><span class="n">setLayoutCount</span> <span class="o">=</span> <span class="n">NUM_DESCRIPTOR_SETS</span><span class="p">;</span><span class="c1">// 给定descriptor set layout数量</span>
<span class="n">pPipelineLayoutCreateInfo</span><span class="p">.</span><span class="n">pSetLayouts</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">desc_layout</span><span class="p">.</span><span class="n">data</span><span class="p">();</span> <span class="c1">// descriptor set layout内存地址</span>

<span class="n">res</span> <span class="o">=</span> <span class="n">vkCreatePipelineLayout</span><span class="p">(</span><span class="n">info</span><span class="p">.</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pPipelineLayoutCreateInfo</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">.</span><span class="n">pipeline_layout</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">res</span> <span class="o">==</span> <span class="n">VK_SUCCESS</span><span class="p">);</span>

</code></pre></div>
<p>pipeline layout将会被用来创建图形管线(graphics pipeline)</p>

  </div>
  <div class="entry">
  (未经授权禁止转载)
  </div>
  <div class="date">
    Written on October 20, 2018
  </div>
  <p>博主将十分感谢对本文章的任意金额的打赏^_^</p>
  <img src="../images/dashang1.jpeg" />
  <img src="../images/dashang2.jpeg" />
    
    
  
<div class="comments">
	<div id="disqus_thread"></div>
	<script type="text/javascript">

	    var disqus_shortname = 'qiujiawei';

	    (function() {
	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
	        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	    })();

	</script>
	<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>

</article>

      </section>
    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          
<a href="mailto:voyagingmk@gmail.com"><i class="svg-icon email"></i></a>


<a href="http://github.com/barryclark/jekyll-now"><i class="svg-icon github"></i></a>




<a href="http://twitter.com/voyagingmk"><i class="svg-icon twitter"></i></a>


        </footer>
      </div>
    </div>

  </body>
</html>
