---
layout: post
title: 无损压缩算法
tags: ['zlib']
published: true
---

<!--more-->


## 名词解释

[defalte](https://en.wikipedia.org/wiki/DEFLATE)：这个东西是压缩算法关键中的关键。

[.zip]( https://en.wikipedia.org/wiki/Zip_(file_format) )：archive format，使用了deflate压缩算法

[.gz](https://en.wikipedia.org/wiki/Gzip)(或gzip格式）: single file compress format，也是使用了deflate压缩算法

[.tar.gz]( https://en.wikipedia.org/wiki/Tar_(computing) )或.tgz：archive format，可认为.gz文件的集合，但又不止是多个.gz的集合，因为tgz利用了文件之间的关联信息，提升了压缩率。

[zlib](https://zlib.net/)：一个通用库，只有源代码，不提供可执行文件，只提供了deflate压缩和解压缩算法代码。linux内核、gzip、7-Zip、libpng、git等等都用了它。

[gzip](https://www.gnu.org/software/gzip/manual/gzip.html)：GNU Gzip，一个工具，提供了gzip和gunzip可执行文件，直接可以用来压缩、解压缩。

7-Zip：类似gzip，也是工具。


## deflate算法 = Huffman Coding + LZ77


### Huffman Coding

### LZ77（Lempel–Ziv Coding）

wiki：[LZ77 and LZ78](https://en.wikipedia.org/wiki/LZ77_and_LZ78#LZ77)

根据wiki所说，实际有2个算法LZ77和LZ78。这2个是其他LZ算法变种的基础（LZW、LZSS、LZMA）。

下面重点介绍LZ77。

#### LZ77关键词：

- input stream：待压缩的字节序列串
- byte：字节，是input stream的基本元素
- coding position：相当于一个指针，指向当前编码位置；也是lookahead buffer的起始位置
- lookahead buffer：就是指coding position为起点，input stream末端为终点的这段字节序列
- window：最大长度为W的滑动窗口，也是以coding position为起点，但是窗口方向是**反向往左**；窗口初始长度为0，随着编码的进行，长度会增长到W，然后就开始往右滑动
- match：当前匹配串
- pointer：当前匹配串的信息，一般用（B，L）表示，B表示Go **B**ack多少个字节（从coding position往左），因为也叫starting offset；L指匹配串从starting offset往右延伸的长度。 pointer为（0，0）时，表示匹配失败。

注意：

- L是可能比B还大的，即匹配串从window区域，延伸进了lookahead buffer区域，又因为匹配串的起点就是lookahead buffer的起点，所以此时出现了**repeat**现象。这个repeat是没问题的，甚至是有用的，可以对不断重复的数据大大压缩。






LZ77是基于字典的算法，思路是，把数据中的重复（冗余）部分，用更短的metadata元信息代替。


这种算法用实例来理解是最快的。微软[这篇文章](
https://msdn.microsoft.com/en-us/library/ee916854.aspx
)就给出了一个例子，这里引用一下：

待压缩数据（流）：AABCBBABC

数据流中每个字节记一个位置标记position，从1开始数，不是从0哦：

<pre>

Position    1    2    3    4    5    6    7    8    9

Byte        A    A    B    C    B    B    A    B    C

</pre>

开始LZ77编码：

![1.png](../images/2018.4/1.png)

LZ77编码后，就输出了最右边一列，注意，这里只是方便理解，实际上不会存成文本形式。

这里重点要搞懂output这一列是怎么来的，用人话来描述下：

0. 设定一个叫滑动窗口（window）的概念，初始时，window是空的：【】
1. 读入第1个字符A，然后在window里match一下，找不到A，match失败，于是输出(0,0)A。window更新为【A】
2. 读入第2个字符A，window里match一下，此时要注意，match的方向是右到左（逆向）。因为在window右起第1个位置就找到了A（叫做go back 1 bytes），所以输出(1, 1)
3. 第一次遇到B，同步骤1，输出(0,0)B，window更新为【AB】

这一列从上往下看，发现其中只有3个格有“数据”，(0,0)A、(0,0)B、(0,0)C。其他格子都只有数字（meta信息），说明其他格子的原文信息都和这3个数据格子有关。

接下来，看看如何把这一列output再解码回原文：

![2.png](../images/2018.4/2.png)

1. 输入(0,0)A，表示直接往输出缓冲区push一个A字符。 【A】
2. 输入(1,1)，只有meta信息，(1,1)意思是它的位置等于1，长度为1，**注意，位置是逆向数，长度是正向数**。显然，(1,1)等于缓冲区的字符A，于是push了一个一样的A。【AA】
3. (0,0)B，和步骤1一样，直接push一个B。【AAB】
4. (0,0)C，同上。【AABC】
5. (2,1)，又是meta信息，位置为2，长度为1，倒着数当前缓冲区，发现起点是B字符，长度为1，所以push一个B。【AABCB】
6. (1,1)，参考步骤5，也是push一个B。【AABCBB】
7. (5,3)，长度终于不为1了，首先在缓冲区倒着数5下，发现是左起第二个A，然后长度3，于是往右再获取2个字符，得到ABC，push到缓冲区，得到【AABCBBABC】


LZ77伪代码(from wiki)：

```
begin
     fill view from input
     while (view is not empty) do 
     begin
          find longest prefix p of view starting in coded part
          i := position of p in window
          j := length of p
          X := first char after p in view
          output(i,j,X)
          add j+1 chars
     end
end
```


### 其他资料

wiki：https://en.wikipedia.org/wiki/DEFLATE

官方解释：https://zlib.net/feldspar.html

[LZ77压缩算法编码原理详解(结合图片和简单代码)](https://www.cnblogs.com/junyuhuang/p/4138376.html )


## zlib

## adler32 和 CRC32
