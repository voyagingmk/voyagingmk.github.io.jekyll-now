---
layout: post_latex
title: 漫谈网络通讯加密（5）AES
tags: ['crypto']
published: true
---

<!--more-->


本文主要目的是剖析AES的来龙去脉，包括源码实现。

# AES


## 资料：

https://www.cnblogs.com/luop/p/4334160.html

https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf#page=3

# 各种加密模式

openSSL实现了多种模式的AES，代码结构很清晰，不同模式有不同的代码文件。

AES的目录：/crypto/aes/，各种模式的目录：/crypto/modes/


## ECB

### ECB加密流程图


![ecb.png](../images/2018.8/ecb.png)

(from [wiki](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation))

这个做法超简单，也意味着很不安全，尤其是原文会重复的情况。

用一张图解释为什么ECB不安全：


![ecb_problem.jpg](../images/2018.8/ecb_problem.jpg)

(from [here](https://students.cs.byu.edu/~cs465ta/homework/ECBReview.html))

## CBC

### CBC加密流程图

![cbc.png](../images/2018.8/cbc-0.png)

(from [wiki](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation))


\\[ C\_\{i\} = E\_\{K\}(C\_\{i - 1\}\oplus P\_\{i\})  \\]

\\[ C\_\{0\} = IV  \\]

其实就是三个步骤的无限循环

1. 块原文和iv异或
2. 块原文加密，输出块密文
3. 把iv设为块密文

优点：

1. 安全性优于ECB

缺点：

1. 多了一个初始化向量IV的问题
2. 因为块与块之间耦合，误差会传递
3. 不能并行计算、随机读取


### CBC加密代码

```c
void CRYPTO_cbc128_encrypt(const unsigned char *in, unsigned char *out,
                           size_t len, const void *key,
                           unsigned char ivec[16], block128_f block)
{
    ···
    // 抽象出来就是这么一段代码
    while (len >= 16) {
        // 第一步
        for (n = 0; n < 16; ++n)
            out[n] = in[n] ^ iv[n];
        // 第二步
        (*block) (out, out, key);
        // 第三步
        iv = out;
        len -= 16;
        in += 16;
        out += 16;
    }
    ···
}
```


## CFB


### CFB加密流程图


![cfb.png](../images/2018.8/cfb.png)

(from [wiki](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation))

\\[ C\_\{i\} = E\_\{K\}(C\_\{i - 1\})\oplus P\_\{i\}  \\]

\\[ C\_\{0\} = IV  \\]

看公式可以发现和CBC很像。


### CFB加密代码

```c
void CRYPTO_cfb128_encrypt(const unsigned char *in, unsigned char *out,
                           size_t len, const void *key,
                           unsigned char ivec[16], int *num,
                           int enc, block128_f block)
{
    unsigned int n;
    size_t l = 0;

    n = *num;
···
    if (16 % sizeof(size_t) == 0) { /* always true actually */
        do {
            while (n && len) {
                *(out++) = ivec[n] ^= *(in++);
                --len;
                n = (n + 1) % 16;
            }
            while (len >= 16) {
                // 第一步 加密IV
                (*block) (ivec, ivec, key);
                // 第二步 和块原文异或输出块密文，同时IV变为块密文
                for (; n < 16; n += sizeof(size_t)) {
                    *(size_t *)(out + n) =
                        *(size_t *)(ivec + n) ^= *(size_t *)(in + n);
                }
                len -= 16;
                out += 16;
                in += 16;
                n = 0;
            }
            if (len) {
                (*block) (ivec, ivec, key);
                while (len--) {
                    out[n] = ivec[n] ^= in[n];
                    ++n;
                }
            }
            *num = n;
            return;
        } while (0);
    }
···
}
```

CFB的加解密几乎一致，有微小区别，于是就用了enc变量来判断是加密还是解密，从而用一个函数搞定CFB。


## OFB


### OFB加密流程图

![ofb.png](../images/2018.8/ofb.png)

(from [wiki](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation))


### OFB加密代码

```c
void CRYPTO_ofb128_encrypt(const unsigned char *in, unsigned char *out,
                           size_t len, const void *key,
                           unsigned char ivec[16], int *num, block128_f block)
{
    unsigned int n;
    size_t l = 0;

    n = *num;
···
    if (16 % sizeof(size_t) == 0) { /* always true actually */
        do {
            while (n && len) {
                *(out++) = *(in++) ^ ivec[n];
                --len;
                n = (n + 1) % 16;
            }
            while (len >= 16) {
                // 循环加密IV
                (*block) (ivec, ivec, key);
                // 加密后的IV和块原文异或，输出块密文
                for (; n < 16; n += sizeof(size_t))
                    *(size_t *)(out + n) =
                        *(size_t *)(in + n) ^ *(size_t *)(ivec + n);
                len -= 16;
                out += 16;
                in += 16;
                n = 0;
            }
            if (len) {
                (*block) (ivec, ivec, key);
                while (len--) {
                    out[n] = in[n] ^ ivec[n];
                    ++n;
                }
            }
            *num = n;
            return;
        } while (0);
    }
    *num = n;
···
}
```

OFB只需要一个CRYPTO_ofb128_encrypt，解密也是用这个函数，加解密的流程是完全对称的。



## CTR


### CTR加密流程图

![ctr.png](../images/2018.8/ctr.png)

(from [wiki](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation))

从图中就可以看出，CTR模式每个块之间的加密是解耦的，于是就有了并行计算的可能性。

### CTR加密代码

```c
void CRYPTO_ctr128_encrypt(const unsigned char *in, unsigned char *out,
                           size_t len, const void *key,
                           unsigned char ivec[16],
                           unsigned char ecount_buf[16], unsigned int *num,
                           block128_f block)
{
    unsigned int n;
    size_t l = 0;

    n = *num;

    if (16 % sizeof(size_t) == 0) { /* always true actually */
        do {
            while (n && len) {
                *(out++) = *(in++) ^ ecount_buf[n];
                --len;
                n = (n + 1) % 16;
            }
            while (len >= 16) {
                // 先加密IV，输出到ecount_buf
                (*block) (ivec, ecount_buf, key);
                // IV加1
                ctr128_inc_aligned(ivec);
                // 用ecount_buf去和块原文异或，输出块密文
                for (n = 0; n < 16; n += sizeof(size_t))
                    *(size_t *)(out + n) =
                        *(size_t *)(in + n) ^ *(size_t *)(ecount_buf + n);
                len -= 16;
                out += 16;
                in += 16;
                n = 0;
            }
            if (len) {
                (*block) (ivec, ecount_buf, key);
                ctr128_inc_aligned(ivec);
                while (len--) {
                    out[n] = in[n] ^ ecount_buf[n];
                    ++n;
                }
            }
            *num = n;
            return;
        } while (0);
    }
    *num = n;
}
```


## XEX和XTS

XEX = Xor–encrypt–xor

XTS = XEX-based tweaked-codebook mode with ciphertext stealing

XEX：

![xts.png](../images/2018.8/xex.png)

(from [wiki](https://en.wikipedia.org/wiki/Disk_encryption_theory#XTS))


![xts.png](../images/2018.8/xex_formula.svg)

可以看到，用来加密原文的X，和三个参数有关：I(IV)、α、j，其中j相当于数组下标，另外2个是常量。因此这个算法是支持随机解密的，只需要知道块的编号j。适合做硬盘数据加密。

XTS：

![xts.png](../images/2018.8/xts.png)


XEX或XTS的特点还有双key双加密算法，下面是openSSL关于XTS的代码：

```c
struct xts128_context {
    void *key1, *key2;
    block128_f block1, block2;
};
```


## [GCM](https://en.wikipedia.org/wiki/Galois/Counter_Mode)


![xts.png](../images/2018.8/gcm.png)


GCM有多牛，牛到有人专门录教学来介绍GCM：

https://www.cryptologie.net/article/277/what-is-gcm-galois-counter-mode/

根据wiki介绍，GCM实质是在CTR模式基础上增加一个Galois Mode，这个mode就是做认证用的（密文完整性）。

看上图也可以发现，前三行和前文的CTR流程图是一样的。


参考资料：

https://blog.csdn.net/mrpre/article/details/79324505