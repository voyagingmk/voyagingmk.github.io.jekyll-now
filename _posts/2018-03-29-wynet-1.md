---
layout: post
title: 线程同步笔记
tags: ['synchronize']
published: true
---

<!--more-->

## wait-free V.S. lock-free

在wiki上这2个东西都是指[Non-blocking algorithm](https://en.wikipedia.org/wiki/Non-blocking_algorithm)。

一个算法被称作非阻塞的前提是：线程的失败或挂起（failure or suspension），不会导致其他线程的失败或挂起。

lock-free算法：在系统级别保证该系统（即用户程序）总是有进展的（progress）。换句话说，如果该系统的所有线程运行足够长时间，能保证至少有一个线程取得进展(make progress），就是lock-free。在lock-free中，如果一个线程被挂起，其他线程依然能取得进展。

wait-free：和lock-free的区别是，wait-free是在lock-free的前提上，进一步要求该系统的线程的操作在有限步骤内能保证完成。所以wait-free必然满足lock-free。

Q：为什么lock-free不等于wait-free？

A：假设一个情景，系统运行在n核环境，并且有n个线程在做一个长操作，其中有m个（m<n）线程能在有限步内完成操作，其他的n - m线程可能会操作失败(fail)并一直不断重试（retry on failure）（失败原因可能那n个线程有关），n-m线程是不能保证在有限步骤内完成操作的（也就是需要wait），所以这种系统就只是lock-free而已。而如果换作wait-free的话，每个线程都能保证操作能在有限步以内完成，并且每个线程和其他线程相互独立，没有依赖，就是无等待，即wait-free。

Q：lock-free是不是就是无锁？

A：确实是要求无锁。因为如果系统内有一个线程获得了锁，然后万一线程异常了没有释放锁（无法保证progress），就会导致等待该线程的其他线程永久饥饿。如果这个锁释不释放对其他线程无所谓，那这个锁也显然无意义。综上，lock-free必然要求无锁。 

wait-free也是无锁？

A：wait-free是比lock-free更进一步的东西，当然也得是无锁。

