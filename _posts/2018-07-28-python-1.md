---
layout: post
title: python源码复习笔记
tags: ['python']
published: true
---

<!--more-->

以前看过python源码，没记笔记，忘光了，现在重新瞧瞧。

# 各种对象的实现

## 通用部分

### PyObject_HEAD 和 PyObject_VAR_HEAD


```c
/* PyObject_HEAD defines the initial segment of every PyObject. */
#define PyObject_HEAD                   \
    _PyObject_HEAD_EXTRA                \
    Py_ssize_t ob_refcnt;               \
    struct _typeobject *ob_type;

#define PyObject_VAR_HEAD               \
    PyObject_HEAD                       \
    Py_ssize_t ob_size; /* Number of items in variable part */
```

这2个东西会出现在各种对象的结构定义里。obj_refcnt显然是引用计数，ob_type是类型元信息的指针，ob_size是变长对象的对象数量信息。

## PyIntObject 普通整数（long）

文件：

- intobject.h
- intobject.c

```c
typedef struct {
    PyObject_HEAD
    long ob_ival;
} PyIntObject;
```

应该是最简单的对象类型了，用一个long存数据信息。

下面是整数对象的类型元信息，其实就是自定义实现了object.h里的_typeobject：

```c
PyTypeObject PyInt_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "int", // tp_name 用于打印
    sizeof(PyIntObject), // tp_basicsize 
    0, // tp_itemsize 因为不是变长类型，所以为0
    // 下面是各种函数指针
    (destructor)int_dealloc,                    /* tp_dealloc */
    (printfunc)int_print,                       /* tp_print */
    ···  
    &int_as_number,                             /* tp_as_number */
    ···
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_CHECKTYPES |
        Py_TPFLAGS_BASETYPE | Py_TPFLAGS_INT_SUBCLASS,          /* tp_flags */
    ···
};
```

PyIntObject的代数运算过程中，可能会转换成PyLongObject。


### 创建

总共4个C API：

```c
PyAPI_FUNC(PyObject *) PyInt_FromString(char*, char**, int);
PyAPI_FUNC(PyObject *) PyInt_FromLong(long);
PyAPI_FUNC(PyObject *) PyInt_FromSize_t(size_t);
PyAPI_FUNC(PyObject *) PyInt_FromSsize_t(Py_ssize_t);
```

第1、3、4个API会根据传入的值的大小，选择创建PyIntObject还是PyLongObject。

所以主要看PyInt_FromLong。

```c
PyObject *
PyInt_FromLong(long ival)
{
    register PyIntObject *v;
    // small_ints
#if NSMALLNEGINTS + NSMALLPOSINTS > 0
    if (-NSMALLNEGINTS <= ival && ival < NSMALLPOSINTS) {
        v = small_ints[ival + NSMALLNEGINTS];
        Py_INCREF(v);
        ···
        return (PyObject *) v;
    }
#endif
    if (free_list == NULL) {
        if ((free_list = fill_free_list()) == NULL)
            return NULL;
    }
    /* Inline PyObject_New */
    v = free_list;
    free_list = (PyIntObject *)Py_TYPE(v);
    (void)PyObject_INIT(v, &PyInt_Type);
    v->ob_ival = ival;
    return (PyObject *) v;
}
```

这段代码涉及到了2大机制，一个是small_ints:

```c
#define NSMALLPOSINTS           257
#define NSMALLNEGINTS           5
static PyIntObject *small_ints[NSMALLNEGINTS + NSMALLPOSINTS];
```

python最多会缓存262个小整数，PyInt_FromLong每次检测val是不是在小整数范围，是的话就复用small_ints里的对象。


small_ints是在python启动的时候就先初始化的：

```c
int
_PyInt_Init(void)
{
    PyIntObject *v;
    int ival;
#if NSMALLNEGINTS + NSMALLPOSINTS > 0
    for (ival = -NSMALLNEGINTS; ival < NSMALLPOSINTS; ival++) {
        if (!free_list && (free_list = fill_free_list()) == NULL)
            return 0;
        /* PyObject_New is inlined */
        v = free_list;
        free_list = (PyIntObject *)Py_TYPE(v);
        (void)PyObject_INIT(v, &PyInt_Type);
        v->ob_ival = ival;
        small_ints[ival + NSMALLNEGINTS] = v;
    }
#endif
    return 1;
}
```

这里面已经用到了free_list。

另一个机制是内存池，一块内存放几百个整数，并且会复用内存，改善了性能：

```c
#define BLOCK_SIZE      1000    /* 1K less typical malloc overhead */
#define BHEAD_SIZE      8       /* Enough for a 64-bit pointer */
#define N_INTOBJECTS    ((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyIntObject))

// 连续存放多个PyIntObject的内存块
// 块与块之间用next指针串起来
struct _intblock {
    struct _intblock *next;
    PyIntObject objects[N_INTOBJECTS];
};


typedef struct _intblock PyIntBlock;

// 当前int内存块的头节点
static PyIntBlock *block_list = NULL;
// 可用的PyIntObject链表的头
static PyIntObject *free_list = NULL;

static PyIntObject *
fill_free_list(void)
{
    PyIntObject *p, *q;
    /* Python's object allocator isn't appropriate for large blocks. */
    p = (PyIntObject *) PyMem_MALLOC(sizeof(PyIntBlock));
    if (p == NULL)
        return (PyIntObject *) PyErr_NoMemory();
    ((PyIntBlock *)p)->next = block_list;
    block_list = (PyIntBlock *)p;
    /* Link the int objects together, from rear to front, then return
       the address of the last int object in the block. */
    // 这里用Py_TYPE指针，把内存块里的所有对象都串成链表，
    // 不过要注意，串的方向是逆的，从后往前，函数最后返回的是最后一个对象
    p = &((PyIntBlock *)p)->objects[0];
    q = p + N_INTOBJECTS;
    while (--q > p)
        Py_TYPE(q) = (struct _typeobject *)(q-1);
    Py_TYPE(q) = NULL;
    return p + N_INTOBJECTS - 1;
}
```

每次一个PyIntObject被回收，就会放进free_list的头：

```c
static void
int_dealloc(PyIntObject *v)
{
    if (PyInt_CheckExact(v)) {
        Py_TYPE(v) = (struct _typeobject *)free_list;
        free_list = v;
    }
    else
        Py_TYPE(v)->tp_free((PyObject *)v);
}
```

## PyLongObject 任意大整数

文件：

- longobject.h
- longobject.c
- longintrepr.h

这个longObject反而不是用long实现了，而是用了复杂的大数运算技巧。

```c
struct _longobject {
	PyObject_VAR_HEAD
	digit ob_digit[1];
};

typedef PY_UINT32_T digit;

typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */
```


PyLongObject的创建和销毁都是直接在堆内存中发生，没有什么复杂优化：

```c
// _PyLong_New是根据数字digit的数量来创建的，而不是数值上的大小
PyLongObject *
_PyLong_New(Py_ssize_t size)
{
    if (size > (Py_ssize_t)MAX_LONG_DIGITS) {
        PyErr_SetString(PyExc_OverflowError,
                        "too many digits in integer");
        return NULL;
    }
    /* coverity[ampersand_in_size] */
    /* XXX(nnorwitz): PyObject_NEW_VAR / _PyObject_VAR_SIZE need to detect
       overflow */
    return PyObject_NEW_VAR(PyLongObject, &PyLong_Type, size);
}


static void
long_dealloc(PyObject *v)
{
    Py_TYPE(v)->tp_free(v);
}
```


## PyFloatObject 普通浮点数(double)

```c
typedef struct {
    PyObject_HEAD
    double ob_fval;
} PyFloatObject;
```

可见对于double范围内的浮点数，都是用double实现的。

```c
PyObject *
PyFloat_FromDouble(double fval)
{
    register PyFloatObject *op;
    if (free_list == NULL) {
        if ((free_list = fill_free_list()) == NULL)
            return NULL;
    }
    /* Inline PyObject_New */
    op = free_list;
    free_list = (PyFloatObject *)Py_TYPE(op);
    (void)PyObject_INIT(op, &PyFloat_Type);
    op->ob_fval = fval;
    return (PyObject *) op;
}
```

观察创建函数，发现也有free_list对象池机制。不过就没有small_ints了，毕竟是实数。


## PyStringObject

```c
typedef struct {
    PyObject_VAR_HEAD
    long ob_shash;
    int ob_sstate;
    char ob_sval[1];

    /* Invariants:
     *     ob_sval contains space for 'ob_size+1' elements.
     *     ob_sval[ob_size] == 0.
     *     ob_shash is the hash of the string or -1 if not computed yet.
     *     ob_sstate != 0 iff the string object is in stringobject.c's
     *       'interned' dictionary; in this case the two references
     *       from 'interned' to this object are *not counted* in ob_refcnt.
     */
} PyStringObject;
```

根据注释看，ob_sval存了ob_size+1个字符字节，+1是为了存'\0'；ob_shash相当于这个字符串的id，用来快速比对字符串；ob_sstate和缓冲池设计有关。

### intern机制

- 这个机制**默认**只对长度为0或1的字符串有用。如果相对更长的字符串启用，那么要使用PyString_InternFromString。
- intern里的字符串是会销毁的，条件是引用计数降到0，因此intern里的PyObject并不持有引用（因为有k、v2个引用，所以是-2）
- 普通创建的intern字符串是SSTATE_INTERNED_MORTAL的，即会销毁，不过IMMORTAL的intern字符串并没有使用到，所以可认为所有都是mortal的。
- 实际上intern机制并不会减少字符串内存分配开销，因为intern机制是发生在内存分配之后的。
- 之所以要创建临时的对象，是因为PyDict_GetItem(PyObject *op, PyObject *key)，查找参数是PyObject，必须创建一个临时对象来作为参数去调用PyDict_GetItem。
- 唯一不会创建临时对象的情况是，空字符串或单字符串，这是通过记录static的characters数组和*nullstring实现的。


### 连接字符串问题

一句话总结，用+号来连接字符串是低效的，要做N-1次内存分配；正确的做法是用join函数。


## PyListObject

```c
typedef struct {
    PyObject_VAR_HEAD
    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
    PyObject **ob_item;

    /* ob_item contains space for 'allocated' elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 <= ob_size <= allocated
     *     len(list) == ob_size
     *     ob_item == NULL implies ob_size == allocated == 0
     * list.sort() temporarily sets allocated to -1 to detect mutations.
     *
     * Items must normally not be NULL, except during construction when
     * the list is not yet visible outside the function that builds it.
     */
    Py_ssize_t allocated;
} PyListObject;
```

### 基本特点

- 也有free_list对象池优化，默认80个
- list的设计像STL的vector
- 因为存的是指针，所以移动元素的开销比较小，插入元素，就会发生大量元素挪动
- list_dealloc会销毁元素列表并回收内存，以及尝试把list对象放进free_list里

### list_resize

- 如果newsize在[allocated, allocated/2]范围，那么不用动内存
- 如果newsize小于allocated/2，还会发生内存收缩，以节省内存


## PyDictObject

### 基本特点

- 基于散列表而不是二叉树
- 冲突解决基于开放定址法，而不是开链


### 结构

```c

// 表示每个dict至少有8个entry
#define PyDict_MINSIZE 8

typedef struct {
    /* Cached hash code of me_key.  Note that hash codes are C longs.
     * We have to use Py_ssize_t instead because dict_popitem() abuses
     * me_hash to hold a search finger.
     */
    Py_ssize_t me_hash;
    PyObject *me_key;
    PyObject *me_value;
} PyDictEntry;

/*
To ensure the lookup algorithm terminates, there must be at least one Unused
slot (NULL key) in the table.
The value ma_fill is the number of non-NULL keys (sum of Active and Dummy);
ma_used is the number of non-NULL, non-dummy keys (== the number of non-NULL
values == the number of Active items).
To avoid slowing down lookups on a near-full table, we resize the table when
it's two-thirds full.
*/
typedef struct _dictobject PyDictObject;
struct _dictobject {
    PyObject_HEAD
    Py_ssize_t ma_fill;  /* # Active + # Dummy */
    Py_ssize_t ma_used;  /* # Active */
    // slots等于2的幂，而ma_mask = slots - 1，mask除了记录了slots数之外还有别的用途  
    Py_ssize_t ma_mask;
    PyDictEntry *ma_table;
    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
    PyDictEntry ma_smalltable[PyDict_MINSIZE];
};
```

### entry的状态机

- active: 被使用中
- dummy：已移除，但因为还在冲突链中，所以不可使用
- unused：未使用

![1.png](../images/2018.7/dict.png)


### PyDict_New

```c
PyObject *
PyDict_New(void)
{
    register PyDictObject *mp;
    if (dummy == NULL) { /* Auto-initialize dummy */
        dummy = PyString_FromString("<dummy key>");
        if (dummy == NULL)
            return NULL;
    }
    if (numfree) {
        mp = free_list[--numfree];
        assert (mp != NULL);
        assert (Py_TYPE(mp) == &PyDict_Type);
        _Py_NewReference((PyObject *)mp);
        if (mp->ma_fill) {
            EMPTY_TO_MINSIZE(mp);
        } else {
            /* At least set ma_table and ma_mask; these are wrong
               if an empty but presized dict is added to freelist */
            INIT_NONZERO_DICT_SLOTS(mp);
        }
        assert (mp->ma_used == 0);
        assert (mp->ma_table == mp->ma_smalltable);
        assert (mp->ma_mask == PyDict_MINSIZE - 1);
    } else {
        mp = PyObject_GC_New(PyDictObject, &PyDict_Type);
        if (mp == NULL)
            return NULL;
        EMPTY_TO_MINSIZE(mp);
    }
    mp->ma_lookup = lookdict_string;
    return (PyObject *)mp;
}
```

主要做了三件事：

- 初始化dummy
- 判断有无free_list，有的话从free_list拿mp，没有的话new一个mp，并重置
- 设置ma_lookup


### lookdict和lookdict_string

lookdict_string是针对string作为key的那些dict的，而lookdict则是一般化的。

区别在于比较字符串不会引发异常，而比较一般化的key可能会引发异常。

共同点是，如果找不到目标key，那么会返回一个entry对象，entry里的me_value为NULL，这个entry不是临时的，而是dict里对应这个key的entry。所以caller可以增加kv到这个entry里。

一个dict默认是用lookdict_string的，只有遇到lookdict_string的key参数不是string，才会提升到lookdict。

lookdict_string是比lookdict高效的，所以能用字符串当key就尽量用字符串。