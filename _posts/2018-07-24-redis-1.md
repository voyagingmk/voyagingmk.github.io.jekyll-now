---
layout: post_latex
title: redis5.0源码学习笔记（1）
tags: ['redis']
published: true
---

Note：本文实际绑定的版本是branch5.0（2018-7-25）。

持续更新中。

<!--more-->

# 数据结构

## SDS 简单动态字符串

### 基本特点

- 涉及字符串的存储基本都基于SDS，例如set nickname Luffy，就创建了nicknmae和Luffy2个SDS
- 不止用于字符串，还用于缓冲区：AOF缓冲区、客户端状态中的输入缓冲区
- 减少修改字符串长度时所需的内存重分配次数
- 杜绝缓冲区溢出问题
- 二进制安全
- 兼容部分C字符串函数

### 源码位置

- sds.h
- sds.c

### 结构定义

```c
typedef char *sds;

/* Note: sdshdr5 is never used, we just access the flags byte directly.
 * However is here to document the layout of type 5 SDS strings. */
struct __attribute__ ((__packed__)) sdshdr5 {
    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr8 {
    uint8_t len; /* used */
    uint8_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr16 {
    uint16_t len; /* used */
    uint16_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr32 {
    uint32_t len; /* used */
    uint32_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
struct __attribute__ ((__packed__)) sdshdr64 {
    uint64_t len; /* used */
    uint64_t alloc; /* excluding the header and null terminator */
    unsigned char flags; /* 3 lsb of type, 5 unused bits */
    char buf[];
};
```

- sds被定义为5种，根据sds的len属性的bit数量划分：5、8、16、32、64bits，5bits的结构没有被使用。
- 紧凑对齐：__attribute__ ((__packed__)) 告诉编译器取消结构在编译过程中的优化对齐,按照实际占用字节数进行对齐，是GCC特有的语法。
- char buf[]很有意思，这样子声明buf，是不会增大sizeof(sdshdr#T)的，因为编译器不知道buf的长度，默认0，而如果声明成指针，就会占4或8字节。
- 综上，5个sds结构的size分别为1、3、5、9、17
- typedef char *sds，指向的是buf字段，如果要访问sdshdr的len、alloc、flags，是用宏SDS_HDR来定位sdshdr的首字节。
- sds依然遵守C语言用'\0'（null terminator）结尾的习惯，使得sds可以使用C字符串函数库。
- len相当于strlen(buf) - 1，记录实际使用了buf的多少字节
- alloc记录buf的容量，不含'\0'
- '\0'由sds自动处理，用户不会感知到'\0'；len、alloc也是
- 因为有len字段，获取sds长度时间复杂度为O(1)
- len、alloc字段能防止缓冲区溢出
- alloc - len = avail, avail有效地降低了频繁内存重分配的开销。这种策略叫空间预分配、惰性空间释放。


### 接口说明

sds.h直接定义的简单接口：

- size_t sdslen(const sds s)：获得s的len字段
- size_t sdsavail(const sds s)：返回这个s的空闲空间字节长度
- sdssetlen(sds s, size_t newlen)：直接设置s的len字段（不验证上限的）
- sdsinclen(sds s, size_t inc)：s的len增加inc（不验证上限的）
- size_t sdsalloc(const sds s)：获得s的alloc字段（并不是分配一个sds）
- sdssetalloc(sds s, size_t newlen)：直接设置s的alloc字段

在sds.c定义的简单接口：

- int sdsHdrSize(char type)：根据SDS_TYPE_xx，返回对应的sdshdr结构的sizeof
- char sdsReqType(size_t string_size)：根据给定大小，返回对应的sdshdr的类型SDS_TYPE_xx，策略是从小到大匹配
- size_t sdsAllocSize(sds s)：等于sdsalloc(s) + 头部长度 + 1，即sds总共占了多少内存
- void *sdsAllocPtr(sds s)：即得到s的sdshdr头部指针
- sds sdsempty(void)：实际调用sdsnewlen("",0);
- sds sdsnew(const char *init)：把C字符串转成sds
- sds sdsdup(const sds s)：克隆一个sds

核心接口：

- sds sdsnewlen(const void *init, size_t initlen)：创建一个新的sds对象，内容为init，len字段为initlen
- void sdsfree(sds s)：销毁一个sds
- void sdsupdatelen(sds s)：更新s的len为strlen的结果，如果sds某个字节被置0，就会导致strlen长度发生变化。
- void sdsclear(sds s)：清空sds，但不释放sds内存
- sds sdsMakeRoomFor(sds s, size_t addlen)：增大sds的alloc，但不影响已存内容和len字段，会返回新的sds(地址发生改变)
- sds sdsRemoveFreeSpace(sds s)：缩小sds的alloc，使得没有avail空间（100%利用率），会返回新的sds
- void sdsIncrLen(sds s, ssize_t incr)：和sdsinclen类似，区别在于加了assert防止超过上限，以及会把newlen字节置0
- sds sdsgrowzero(sds s, size_t len)：oldlen增大到len，len - oldlen这段空间会自动置0
- sds sdscatlen(sds s, const void *t, size_t len)：即concat操作
- sds sdscat(sds s, const char *t)：用strlen(t)去调用sdscatlen
- sds sdscatsds(sds s, const sds t)：concat2个sds
- sds sdscpylen(sds s, const char *t, size_t len)：把t复制进sds
- sds sdscpy(sds s, const char *t)：用strlen(t)去调用sdscpylen

其他接口：


- int sdsll2str(char *s, long long value)：long long转成字符串并放进s缓冲区
- int sdsull2str(char *s, unsigned long long v)：同上
- sds sdsfromlonglong(long long value) ：long long转成sds
- sds sdscatvprintf(sds s, const char *fmt, va_list ap) ：打印相关
- sds sdscatprintf(sds s, const char *fmt, ...)：打印相关
- sds sdscatfmt(sds s, char const *fmt, ...)：格式化相关
- sds sdstrim(sds s, const char *cset) ：trim掉头尾连续字符串，用cset识别
- void sdsrange(sds s, ssize_t start, ssize_t end)：返回s的子串
- void sdstolower(sds s)：转小写
- void sdstoupper(sds s)：转大写
- int sdscmp(const sds s1, const sds s2)：比较两个sds
- sds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count)：用指定的sep字符串切割sds
- void sdsfreesplitres(sds *tokens, int count)：sdssplitlen、sdssplitargs后要调用这个释放数组
- sds sdscatrepr(sds s, const char *p, size_t len) ：concat p串，p会被转成escaped的串
- int is_hex_digit(char c)：判断是不是hex字符
- int hex_digit_to_int(char c)：hex字符转int
- sds *sdssplitargs(const char *line, int *argc)：把用空格间隔的参数列表转成sds数组
- sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) ：sdsmapchars(mystring, "ho", "01", 2)，"hello" -> "0ell1"
- sds sdsjoin(char **argv, int argc, char *sep)：join一组C字符串
- sds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen)：join一组SDS对象

# 参考资料：


https://blog.csdn.net/z69183787/article/details/81121779