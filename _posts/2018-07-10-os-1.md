---
layout: post
title: 《现代操作系统》17年第四版 阅读笔记
tags: ['os']
published: true
---

<!--more-->

## 系统调用

### fork

创建一个原有进程的精确副本。

被复制的东西：

- 所有的文件描述符
- 所有的寄存器

没被复制的东西：

- 程序正文

在fork后，原有的进程和其副本（父与子）就分开了。


返回值，用来在进程里区分谁是父谁是子：

- 在子进程中该值为0
- 在父进程中等于子进程的PID


shell为例：

```
while(true) {
    type_prompt();
    read_command(cmd, params);
    if(fork()!=0) {
        // 父
        waitpid(-1, &status, 0);
    } else {
        // 子
        execve(command, params, 0);
    }
}
```

### waitpid

参数：

- 子进程PID，填-1就是任意一个子进程PID
- status（statloc）子进程的返回状态码
- 一般为0

### exec

使得整个核心映像（core image）被一个文件所替代。

参数：将要执行的文件名、一个指向变量数组的指针、一个指向环境数组的指针（通常为0）

例子：

cp file1 file2

execve(cp, [file1, file2], 0)

main(argc, argv, envp)

argc为3，argv[0]为cp，argv[1]为file1，argv[2]为file2；没有envp。

### exit(status)

status是用户指定的，status其实就是waitpid的staloc，子进程设定的status最终可以告诉父进程。


### link

在unix中，每个文件都有唯一的编号（i-node）。

每个目录有一个i-node到文件名的表。

link时，是在指向目录里面创建一个新条目，i-node为原文件的i-node，文件名都link参数里指定的文件名。

目录和i-node是双向指向的，i-node也存有一个表，记录了指向该i-node的目录项。


# 进程和线程

## 进程模型


### CPU利用率

- t1, 一个进程等待I/O操作的时间
- t, 一个进程停留在内存中时间
- p, 一个进程等待I/O操作的时间与其停留在内存中时间的比。
- n为同时存在的进程数量

利用率 = \\( 1 - p\^\{n\}\\)

这是简单模型，只适用于进程之间互相独立。例如对于单CPU，即使进程就绪，但已有一个进程正在被CPU处理，那么还是会等待。

### 用户空间线程

优缺点：


### 内核空间线程



### 调度程序激活机制 和 上行调用（upcall)



### IPC：信号量

- 创建信号量：sem_t *sem_open(const char *name, int oflag, 权限, 初始值)。返回值：返回一个信号量对象，若失败，则返回SEM_FAILED，并设置errno。[man page](https://linux.die.net/man/3/sem_open)
- P(down)操作，即int sem_wait(sem_t *sem)，检查信号量的值是不是大于0，若大于0，则减1并返回；若等于0，则进程睡眠，sem_wait阻塞不返回；非阻塞版本是sem_trywait，用返回值EAGAIN代替阻塞；限时的down操作是sem_timedwait，使得阻塞不是永久的。返回值：0代表成功，-1代表失败，并设置errno。
- V(up)操作，即int sem_post(sem_t *sem),对信号量加1，若是从0变1，那么那些阻塞在这个信号量的进程或线程会被唤醒。返回值同P。V操作是怎么都不会阻塞的。
- 本进程关闭信号量：int sem_close(sem_t *sem)。没什么特别的。
- 真·销毁信号量：sem_unlink，前提是open了信号量的进程已经调用了close或者已经结束了进程（调用了exit或者main函数返回），如果还没close就调用，那么没效果。

[github代码实例](https://github.com/tomasbruckner/minimalSemaphoreDemo/blob/master/semaphore_synchronization/semaphore_synchronization.c)，双信号量实现父进程和子进程的同步。

信号量2个能力：

- 实现互斥量
- 实现计数

### IPC：futex 快速用户空间互斥


- linux特有
- 实现了基本的锁（很像互斥锁），但避免了陷入内核
- 内核服务：提供一个等待队列，它允许多个进程在一个锁上等待。把进程放到等待队列代价很大（系统调用）。
- 避免锁争用：没有争用时，futex完全在用户空间工作；加锁时，如果锁没有被锁，那么直接加锁成功，不需要陷入内核；如果已经被锁了，执行系统调用把线程放到等待队列（不自旋）。


### IPC：管程 montior

原因：为了更易于编写正确的程序。

- 管程是编程语言的组成部分，能不能用管程得看是什么语言，例如java
- 任一时刻管程中只能有一个活跃进程
- 进程可在任何需要的时候调用管程中的过程（procdeure)
- 进入管程是的互斥由编译器负责，出错的可能性要小得多
- 写管程的人无需关心编译器是如何实现互斥的，只需知道将所有临界区转换成管程即可

### IPC：消息传递

其实就是用socket来实现IPC。