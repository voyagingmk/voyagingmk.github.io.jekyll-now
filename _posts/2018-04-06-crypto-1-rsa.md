---
layout: post_latex
title: 漫谈网络通讯加密（1）加密学算法之RSA
tags: ['crypto']
published: true
---

首先强推大神的文章：

[RSA算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)

[RSA算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

（Note：里面有些图片要上梯子才能加载，chart.googleapis.com，你懂得）

<!--more-->

# RSA算法

## 需要用到的数论知识

### 每个正整数n都能够被分解成多个质数的乘积

\\[ n = p\_\{1\}\^\{ a\_\{1} \} p\_\{2\}\^\{ a\_\{2} \} \cdots p\_\{k\}\^\{ a\_\{k} \}  \\]

这个分解是唯一的。不过质因子的乘积顺序可以变。质因子可以重复出现。

### 全等关系式

当2个整数a、b的差等于k个整数n的积时（k可以是任意整数）:

\\[ a - b = kn \\]

可以写成：

 \\[a \equiv b (mod \ n) \\]

例如a = 9，b = 1，n = 4时，有:

\\[ a - b = 9 - 1 = 2 \cdot 4 \\]

\\[ 9 \equiv 1 (mod \ 4) \\]

### [欧拉函数(Euler's function)](https://en.wikipedia.org/wiki/Euler_function)

\\[ \phi (n) = \prod \_\{k=1\}\^\{ \infty \} ( 1 - n\^\{k\} ) \\]

\\( \phi (n) \\)的含义是：在小于等于n的正整数之中，有\\( \phi (n) \\)个数与n构成互质关系。


这条公式深究起来是蛮复杂的。简单地去理解，其实是这么一个公式：

\\[ \\phi (n) = n ( 1 - \frac\{ 1 \}\{ p\_\{1\} \} ) ( 1 - \frac\{ 1 \}\{ p\_\{2\} \} ) \cdots ( 1 - \frac\{ 1 \}\{ p\_\{k\} \} )  \\]

\\( p\_\{1\} \ p\_\{2\} \cdots p\_\{k\} \\) 就是上文说的质因数分解了。注意，这些质数是不能重复的，每个不同的p只会在\\(\\phi (n) \\)公式里出现一次。

- **特殊情况1**，当n为质数时，质因数分解得到1和n，1不算，那么\\( \phi (n) \\)简化成：

\\[ \\phi (n) = n ( 1 - \frac\{ 1 \}\{ n \} )  \\]

\\[ \\phi (n) = n  - \frac\{ n \}\{ n \}  = n - 1 \\]


- **特殊情况2**，当n为2个质数p、q的积时：

\\[ \\phi (n) = \\phi (pq) = (pq) ( 1 - \frac\{ 1 \}\{ p \} ) ( 1 - \frac\{ 1 \}\{ q\} )   \\]

\\[ \\phi (pq) = ( p - \frac\{ p \}\{ p \} ) ( q - \frac\{ q \}\{ q\} )   \\]

\\[ \\phi (pq) = ( p - 1 ) ( q - 1 )   \\]

资料：

https://artofproblemsolving.com/wiki/index.php?title=Euler%27s_totient_function

https://www.geeksforgeeks.org/eulers-totient-function/

### [欧拉定理(Euler's theorem)](https://en.wikipedia.org/wiki/Euler%27s_theorem)

对于任意的互质的2个正整数a和n，都满足以下全等关系式：

\\[ a\^\{\\phi \(n) \} \\equiv 1 (mod \ n) \\]

### [费马小定理(Fermat's little theorem)](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)

这个是欧拉定理的特殊情况：若正整数n还是个质数，把n记为p，那么有：

\\[ \\phi (p) = p - 1 \\]

代入欧拉定理公式，得到：

\\[ a\^\{ p - 1 \} \\equiv 1 (mod \ p) \\]

这就是费马小定理。

### [模逆元(Modular multiplicative inverse)](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)

当2个正整数a和n互质时（Note：a、n本身不一定是质数），必然存在一个整数x，使得：

\\[ ax \equiv 1 (mod \ n) \\]

x就是所谓的模逆元。另外限定x取值范围为[0, n-1]，就使得**模逆元x是唯一的**。


x的存在性证明：

可以用欧拉定理来证明，因为a和n互质，所以有：

\\[ a\^\{\\phi \(n) \} \\equiv 1 (mod \ n) \\]

对左边转换一下：

\\[ a\cdot a\^\{\\phi \(n) - 1 \} \\equiv 1 (mod \ n) \\]

显然，模逆元x的其中一个解等于：

\\[ x = a\^\{\\phi \(n) - 1 \} \\]

这个解可能会超过限定范围，得做模运算才能得到真正的模逆元：

\\[ x = a\^\{\\phi \(n) - 1 \} (mod \ n) \\]

直接用这条公式计算x，据说比较慢，更快速的算法是用[扩展欧几里得算法](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)。

中文wiki有更详细的例子：[扩展欧几里得算法](https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)。

## RSA加密解密原理

### 准备

用户首先任意选择2个质数p、q，并计算p、q乘积n：

\\[ n = pq \\]

然后应用欧拉定理的特殊情况2公式：

\\[ \phi (n) = (p - 1)(q - 1) \\]

这2个值算出来时，就可以**彻底删除p、q**了。后面的计算步骤和原始的p、q无关。

接着，用户随机选择一个正整数e，e的取值范围为\\( [1, \phi (n)] \\)。

e确定后，计算关于\\( e、\phi (n) \\)的模逆元d：

\\[ ed \equiv 1 (mod \ \phi (n) ) \\]

此时，用户总共持有4个对象：

- \\( n \\)
- \\( \phi (n) \\)
- \\( e \\)
- \\( d \\)

其中的(e、n)组成了RSA算法的公钥；(d, n)组成了私钥。

现在举个栗子来理解上面的流程：

假设p、q分别为61、53，则\\(n、\phi (n) \\)分别等于：

\\( n = 61 \cdot 53 = 3233\\)

\\( \phi (n) = (61 - 1) (53 - 1) = 3120 \\)

e选择17（在范围[1,3120]内即可），并算出d：

\\( d = 2753 \\)

（用扩展欧几里得算法计算得到）

### 加密

假设用户A把公钥(e,n)给到用户B，让用户B给他发送一个原文信息m，m为一个数字。

原文m的加密过程如下：

\\[ m\^\{e\} \equiv c ( mod \ n) \\]

### 解密


### RSA算法的可靠性保证


公钥是(e,n)，私钥是(d,n)，攻击者唯一能知道的只有公钥(e,n)，那么攻击者是否能算出d，得到私钥(d,n)呢？

破解d的思路：

1. \\( ed \equiv 1 (mod \ \phi (n) ) \\)，只有知道e和\\(\phi (n) \\)，才能算出d；
2. 而 \\( \phi (n) = (p - 1)(q - 1) \\)，只有知道p和q，才能算出\\(\phi (n) \\)；
3. 而 pq = n。只有对n做质因数分解，才能算出p和q。

所以，能否在短时间内对n做分解得到p、q，是RSA算法是否可靠的关键。目前来说，还没有快速地求质因数分解的算法。

### 参考资料：

https://certauth.epfl.ch/rsa/node3.html

# RSA-PSS