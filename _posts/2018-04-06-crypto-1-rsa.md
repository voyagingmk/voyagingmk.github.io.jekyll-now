---
layout: post_latex
title: 漫谈网络通讯加密（1）加密学算法之RSA
tags: ['crypto']
published: true
---

首先强推大神的文章：

[RSA算法原理（一）](http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html)

[RSA算法原理（二）](http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html)

（Note：里面有些图片要上梯子才能加载，chart.googleapis.com，你懂得）

<!--more-->

# RSA算法

## 需要用到的数论知识

### 每个正整数n都能够被分解成多个质数的乘积

\\[ n = p\_\{1\}\^\{ a\_\{1} \} p\_\{2\}\^\{ a\_\{2} \} \cdots p\_\{k\}\^\{ a\_\{k} \}  \\]

这个分解是唯一的。不过质因子的乘积顺序可以变。质因子可以重复出现。

### 全等关系式

当2个整数a、b的差等于k个整数n的积时（k可以是任意整数）:

\\[ a - b = kn \\]

可以写成：

 \\[a \equiv b (mod \ n) \\]

例如a = 9，b = 1，n = 4时，有:

\\[ a - b = 9 - 1 = 2 \cdot 4 \\]

\\[ 9 \equiv 1 (mod \ 4) \\]

### [欧拉函数(Euler's function)](https://en.wikipedia.org/wiki/Euler_function)

![3.svg](../images/2018.4/eulerfunction.svg)

这个东西深究起来是蛮复杂的。简单地去理解，其实是这么一个公式：

\\[ \\phi (n) = n ( 1 - \frac\{ 1 \}\{ p\_\{1\} \} ) ( 1 - \frac\{ 1 \}\{ p\_\{2\} \} ) \cdots ( 1 - \frac\{ 1 \}\{ p\_\{k\} \} )  \\]

\\( p\_\{1\} \ p\_\{2\} \cdots p\_\{k\} \\) 就是上文说的质因数分解了。注意，这些质数是不能重复的，每个不同的p只会在\\(\\phi (n) \\)公式里出现一次。

特殊的，当n为质数时，质因数分解得到1和n，1不算，那么\\( \phi (n) \\)简化成：

\\[ \\phi (n) = n ( 1 - \frac\{ 1 \}\{ n \} )  \\]

\\[ \\phi (n) = n  - \frac\{ n \}\{ n \}  = n - 1 \\]

资料：

https://artofproblemsolving.com/wiki/index.php?title=Euler%27s_totient_function

https://www.geeksforgeeks.org/eulers-totient-function/

### [欧拉定理(Euler's theorem)](https://en.wikipedia.org/wiki/Euler%27s_theorem)

对于任意的互质的2个正整数a和n，都满足以下全等关系式：

\\[ a\^\{\\phi \(n) \} \\equiv 1 (mod \ n) \\]

### [费马小定理(Fermat's little theorem)](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem)

这个是欧拉定理的特殊情况：若正整数n还是个质数，把n记为p，那么有：

\\[ \\phi (p) = p - 1 \\]

代入欧拉定理公式，得到：

\\[ a\^\{ p - 1 \} \\equiv 1 (mod \ p) \\]

这就是费马小定理。

### [模逆元(Modular multiplicative inverse)](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)

当2个正整数a和m互质时，必然存在一个整数x，使得：

\\[ ax \equiv 1 (mod \ m) \\]

**模逆元是唯一的**。


# RSA-PSS