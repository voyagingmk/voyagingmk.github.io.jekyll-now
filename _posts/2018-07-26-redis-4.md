---
layout: post_latex
title: redis5.0源码学习笔记（2）分布式相关
tags: ['redis']
published: true
---

Note：本文实际绑定的版本是branch5.0（2018-7-25）。


<!--more-->


## cluster.h

### slots

```c
#define CLUSTER_SLOTS 16384
```

redis集群用了槽的概念，总共限定16384个slots。

每个kv的key，用CRC16（hash）然后取模16384，得到槽索引值，就知道对应哪个槽了。

另外还有个节点的概念，节点是指redis集群里单个redis服务器。

节点数量上限是16384，即一个节点一个槽，下限是1。

节点和槽的对应关系：

这个架构下的2个关键点：

- 添加删除节点，槽需要在节点之间移动
- 槽的移动过程中，服务依然可用

### 单节点的问题

因为不同节点存的数据是不一样的，所以单节点故障就会导致那部分数据不可用，实际上，这会导致整个redis集群不可用，因为要保证一致性。

解决方案是单节点要实现主从复制，例如一个主节点可以有一个从节点，这样节点数量会翻一倍。



### 集群的主从一致性问题

redis并不能保证强一致。这是因为使用了异步复制的设计：

1. 客户端向某主节点调用会触发write的指令，例如hmset
2. 该主节点立即执行并立即回复客户端执行结果
3. 主节点将写操作复制给它的所有从节点

如果2和3调换，就是强一致，但是就会损失可用性（C和A不能同时达到）。

## 本机搭建一个集群教程

1. 随便创建一个文件夹如test
2. 在test里面创建6个文件夹：7000、7001、7002、7003、7004、7005
3. 复制redis的redis-server和redis-cli到test文件夹
4. 每个700x子文件夹放一个redis.conf，并启动： ../redis-server ./redis.conf
5. 在test文件夹执行：./redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 --cluster-replicas 1


redis.conf：

```
port 7002
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
```

执行了create指令后，会输出：

```c
>>> Performing hash slots allocation on 6 nodes...
Master[0] -> Slots 0 - 5460
Master[1] -> Slots 5461 - 10922
Master[2] -> Slots 10923 - 16383
Adding replica 127.0.0.1:7003 to 127.0.0.1:7000
Adding replica 127.0.0.1:7004 to 127.0.0.1:7001
Adding replica 127.0.0.1:7005 to 127.0.0.1:7002
>>> Trying to optimize slaves allocation for anti-affinity
[WARNING] Some slaves are in the same host as their master
M: 10921696574cc509be40ae48d704ef6ca67b4171 127.0.0.1:7000
   slots:[0-5460] (5461 slots) master
M: c1f776cd30527cffb9046e01ca30031e1d5bc578 127.0.0.1:7001
   slots:[5461-10922] (5462 slots) master
M: 77001d974c1f5f6db0256622b276293ec36359fb 127.0.0.1:7002
   slots:[10923-16383] (5461 slots) master
S: 235238c0774c50721e8f8f0fad6ca8efb13a6f19 127.0.0.1:7003
   replicates 10921696574cc509be40ae48d704ef6ca67b4171
S: 248661b074edd363e91d151391577c4ac0c43bdf 127.0.0.1:7004
   replicates c1f776cd30527cffb9046e01ca30031e1d5bc578
S: 61199063df69d57a096a16ab2c97138f59aeb36d 127.0.0.1:7005
   replicates 77001d974c1f5f6db0256622b276293ec36359fb
Can I set the above configuration? (type 'yes' to accept):

```

槽的分配都显示出来了：

- 主节点0，对应槽[0, 5460]
- 主节点1，对应槽[5461, 10922]
- 主节点2，对应槽[10923, 16383]

主节点是端口分别为7000、7001、7002的节点；7003、7004、7005是相应的从节点。

这里还有个细节：

```
>>> Trying to optimize slaves allocation for anti-affinity
[WARNING] Some slaves are in the same host as their master
```

这2行表示redis分析出了这些节点之间组织得并不好，从节点和主节点在同一个主机上。当然现在是测试，忽略它。


键入yes后：

```c
[OK] All nodes agree about slots configuration.
>>> Check for open slots...
>>> Check slots coverage...
[OK] All 16384 slots covered.
```

就会把配置告诉所有节点，并且让节点建立起相互通讯，完成集群初始化。

下面做下测试。

- 启动一个客户端连接到7000节点，并发送一个set指令：

```c
/redis-cli -c -p 7000
127.0.0.1:7000> set foo bar
-> Redirected to slot [12182] located at 127.0.0.1:7002
OK
127.0.0.1:7002> 
```

提示这个set指令被重定向到槽12182，即7002节点，根据前面的配置信息，7002是一个主节点。指令返回后，发现终端变成127.0.0.1:7002> ，说明之后的指令都是发往7002主机（也被重定向了）。

- 再发一个set指令：

```c
127.0.0.1:7002> set hello world
-> Redirected to slot [866] located at 127.0.0.1:7000
OK
127.0.0.1:7000> 
```

现在又回到了7000，hello对应的槽是866。

- 测试读指令，发送一个get：


```c
127.0.0.1:7000> get foo
-> Redirected to slot [12182] located at 127.0.0.1:7002
"bar"
127.0.0.1:7002> 
```

因为foo是在7002上的，所以又回到了7002，并拿到了刚才写入的"bar"。

- 另外开一个redis-cli来测试下：

```c
./redis-cli -c -p 7001
127.0.0.1:7001> get hello
-> Redirected to slot [866] located at 127.0.0.1:7000
"world"
127.0.0.1:7000> 
```

这次连的是另外一台主服务器，被重定向到7000，没什么问题。


- 测试从节点：

```c
./redis-cli -c -p 7005
127.0.0.1:7005> get hello
-> Redirected to slot [866] located at 127.0.0.1:7000
"world"
127.0.0.1:7000> 
```

和连接主节点7001的一样，也是重定向到7000，没什么问题。

- 再测试下在从节点执行del指令：

```c
./redis-cli -c -p 7005
127.0.0.1:7005> del hello
-> Redirected to slot [866] located at 127.0.0.1:7000
(integer) 1
127.0.0.1:7000> 
```

和预期的一样，都是先算出槽号并找出对应的目标节点，重定向到目标节点上执行。


## 资料

http://www.redis.cn/topics/cluster-tutorial.html