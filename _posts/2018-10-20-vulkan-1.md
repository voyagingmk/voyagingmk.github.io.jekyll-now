
# 安装SDK

LunarG的SDK、Runtime，以及NVidia的驱动。

# 实例

## LunarG出品的

https://github.com/LunarG/VulkanSamples

mkdir build
cd build
python ../scripts/update_deps.py --arch Win64
cmake -C helper.cmake -G "Visual Studio 14 2015 Win64" ..
或
cmake -C helper.cmake -G "Visual Studio 15 2017 Win64" ..
cmake --build .

Note：需要python3环境。如果已經有Python2，可以自定义模式安裝python3并取消勾选所有选项（最精简就够了），安装后把path指向python3目录。再执行update_deps.py。最后再改回去python2

### 编译问题：

__std_reverse_trivially_swappable_8：貌似是同时安装VS2015和VS2017才会出现的问题。用cmake -C helper.cmake -G "Visual Studio 15 2017 Win64" .. 试试。




## 民间出品的

https://github.com/SaschaWillems/vulkan


这个不需要安装LunarG的SDK就可以编译运行，很傻瓜化（但应该需要安装新的NVidia驱动）。实质是直接把LunarG的vulkan include目录嵌进去了。


# 学习笔记

## 1. 创建必要的VkInstance对象（vkCreateInstance）

```c
VkResult VKAPI_CALL vkCreateInstance(
    const VkInstanceCreateInfo*                 pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkInstance*                                 pInstance);

void VKAPI_CALL vkDestroyInstance(
    VkInstance                                  instance,
    const VkAllocationCallbacks*                pAllocator);
```

给定pCreateInfo对象，可以创建VkInstance对象（放在pInstance返回），要通过VkResult检查是否正确创建。

## 2. 枚举设备enumerate_devices（vkEnumeratePhysicalDevices）

这一步是确定本机有什么物理设备（GPU），写入到VkPhysicalDevice数组里。


```c
	VkInstance  inst;
	std::vector<VkPhysicalDevice> gpus;
	···
    uint32_t gpu_count = 1;
    VkResult U_ASSERT_ONLY res = vkEnumeratePhysicalDevices(inst, &gpu_count, NULL);
    assert(gpu_count);
    gpus.resize(gpu_count);
    res = vkEnumeratePhysicalDevices(inst, &gpu_count, gpus.data());
    assert(!res && gpu_count >= 1);
```

vkEnumeratePhysicalDevices同一个接口用两次，第一次的第三个参数设NULL，可以获取gpu数量；知道gpu数量后，第二次传入一个raw的VkPhysicalDevice数组指针，直接让api初始化这个数组。

因为是raw的数组指针，所以要先resize这个vector，确保有足够的空间放数据。


## 3. 创建一个（逻辑）设备对象 vkCreateDevice


```c
	uint32_t queue_family_count;
	std::vector<VkQueueFamilyProperties> queue_props;

	vkGetPhysicalDeviceQueueFamilyProperties(gpus[0], &queue_family_count, NULL);
	assert(queue_family_count >= 1);

	queue_props.resize(queue_family_count);
	vkGetPhysicalDeviceQueueFamilyProperties(gpus[0], &queue_family_count, queue_props.data());
	assert(queue_family_count >= 1);
```

vkGetPhysicalDeviceQueueFamilyProperties的用法和vkEnumeratePhysicalDevices非常相似。

vkGetPhysicalDeviceQueueFamilyProperties的用途是获取这个gpu的queue_family_count和queue_props。queue_props则是一个VkQueueFamilyProperties数组。

```c
typedef struct VkQueueFamilyProperties {
    VkQueueFlags    queueFlags;
    uint32_t        queueCount;
    uint32_t        timestampValidBits;
    VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;
```
注意这个是family，每个family里可以有多个queue，queue的数量看queueCount。每个family对应多个flags集合：

```c
typedef enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 0x00000001,
    VK_QUEUE_COMPUTE_BIT = 0x00000002,
    VK_QUEUE_TRANSFER_BIT = 0x00000004,
    VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
    VK_QUEUE_PROTECTED_BIT = 0x00000010,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 0x7FFFFFFF
} VkQueueFlagBits;
```

例如一般第一个family的flags是15，即VK_QUEUE_GRAPHICS_BIT | VK_QUEUE_COMPUTE_BIT | VK_QUEUE_TRANSFER_BIT | VK_QUEUE_SPARSE_BINDING_BIT。


queue_family_count和queue_props有了后，就可以创建device了。创建device的接口是vkCreateDevice。

在调用这个接口前需要准备好VkDeviceQueueCreateInfo对象、VkDeviceCreateInfo对象。

VkDeviceQueueCreateInfo对象：

```c

VkDeviceQueueCreateInfo queue_info = {};
for (unsigned int i = 0; i < queue_family_count; i++) {
    if (queue_props[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) {
        queue_info.queueFamilyIndex = i;
        break;
    }
}

float queue_priorities[1] = {0.0};
queue_info.sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
queue_info.pNext = NULL;
queue_info.queueCount = 1;
queue_info.pQueuePriorities = queue_priorities;

```

VkDeviceCreateInfo对象：

```c

VkDeviceCreateInfo device_info = {};
device_info.sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO;
device_info.pNext = NULL;
device_info.queueCreateInfoCount = 1;
device_info.pQueueCreateInfos = &queue_info;
device_info.enabledExtensionCount = 0;
device_info.ppEnabledExtensionNames = NULL;
device_info.enabledLayerCount = 0;
device_info.ppEnabledLayerNames = NULL;
device_info.pEnabledFeatures = NULL;
```

然后就：

```c
    VkDevice device;
    VkResult U_ASSERT_ONLY res = vkCreateDevice(gpus[0], &device_info, NULL, &device);
    assert(res == VK_SUCCESS);

    vkDestroyDevice(device, NULL);
```

## 4. 创建VkCommandPool和VkCommandBuffer

vkCreateCommandPool创建池，vkAllocateCommandBuffers则从池里分配buffer：

```c
    VkDevice device;
    VkCommandPool cmd_pool;
    VkCommandBuffer cmd;
    
    VkCommandPoolCreateInfo cmd_pool_create_info = {};
    cmd_pool_create_info.sType = VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO;
    cmd_pool_create_info.pNext = NULL;
    cmd_pool_create_info.queueFamilyIndex = graphics_queue_family_index; // 上一步的
    cmd_pool_create_info.flags = 0;

    res = vkCreateCommandPool(device, &cmd_pool_create_info, NULL, &cmd_pool);
    assert(res == VK_SUCCESS);

    /* Create the command buffer from the command pool */
    VkCommandBufferAllocateInfo cmd_buffer_alloc_info = {};
    cmd_buffer_alloc_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
    cmd_buffer_alloc_info.pNext = NULL;
    cmd_buffer_alloc_info.commandPool = cmd_pool;
    cmd_buffer_alloc_info.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
    cmd_buffer_alloc_info.commandBufferCount = 1;

    res = vkAllocateCommandBuffers(device, &cmd_buffer_alloc_info, &cmd);
    assert(res == VK_SUCCESS);
```


## 5. swapchain


### extension

首先要在创建instance之前插个步骤，设置instance_extension_names：

```c
void init_instance_extension_names(struct sample_info &info) {
    info.instance_extension_names.push_back(VK_KHR_SURFACE_EXTENSION_NAME);
#ifdef __ANDROID__
    info.instance_extension_names.push_back(VK_KHR_ANDROID_SURFACE_EXTENSION_NAME);
#elif defined(_WIN32)
    info.instance_extension_names.push_back(VK_KHR_WIN32_SURFACE_EXTENSION_NAME);
#elif defined(VK_USE_PLATFORM_IOS_MVK)
    info.instance_extension_names.push_back(VK_MVK_IOS_SURFACE_EXTENSION_NAME);
#elif defined(VK_USE_PLATFORM_MACOS_MVK)
    info.instance_extension_names.push_back(VK_MVK_MACOS_SURFACE_EXTENSION_NAME);
#elif defined(VK_USE_PLATFORM_WAYLAND_KHR)
    info.instance_extension_names.push_back(VK_KHR_WAYLAND_SURFACE_EXTENSION_NAME);
#else
    info.instance_extension_names.push_back(VK_KHR_XCB_SURFACE_EXTENSION_NAME);
#endif
}
```

还有device的extension：

```c
void init_device_extension_names(struct sample_info &info) {
    info.device_extension_names.push_back(VK_KHR_SWAPCHAIN_EXTENSION_NAME);
}
```

swapchain的解释：就是一系列image buffer，gpu会往里面绘制东西，这些buffer可显示到硬件。

正因为是由硬件来绘制，所以才需要一个device级别的扩展，才能使得swapchain工作。


### pSupportsPresent

先是查出有多少queue支持presenting，总共要遍历queue_family_count次：

```c
    // Iterate over each queue to learn whether it supports presenting:
    VkBool32 *pSupportsPresent = (VkBool32 *)malloc(info.queue_family_count * sizeof(VkBool32));
    for (uint32_t i = 0; i < info.queue_family_count; i++) {
        vkGetPhysicalDeviceSurfaceSupportKHR(info.gpus[0], i, info.surface, &pSupportsPresent[i]);
    }
```

有了pSupportsPresent布尔数组后，就遍历下看看哪个queue可以作为graphics queue、present queue ：

```c
// Search for a graphics and a present queue in the array of queue
// families, try to find one that supports both
info.graphics_queue_family_index = UINT32_MAX;
info.present_queue_family_index = UINT32_MAX;
for (uint32_t i = 0; i < info.queue_family_count; ++i) {
    // 前提得支持Graphics，再看pSupportsPresent
    if ((info.queue_props[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) != 0) {
        if (info.graphics_queue_family_index == UINT32_MAX)
            info.graphics_queue_family_index = i;

        if (pSupportsPresent[i] == VK_TRUE) {
            info.graphics_queue_family_index = i;
            info.present_queue_family_index = i;
            break;
        }
    }
}
```

有可能找不到合适的present_queue_family_index（也意味着没有同时支持graphics和present的queue），则随便找一个pSupportsPresent[i]为VK_TRUE的queue，即让graphic queue和present queue分离：

```c
if (info.present_queue_family_index == UINT32_MAX) {
    // If didn't find a queue that supports both graphics and present, then
    // find a separate present queue.
    for (size_t i = 0; i < info.queue_family_count; ++i)
        if (pSupportsPresent[i] == VK_TRUE) {
            info.present_queue_family_index = i;
            break;
        }
}
// 此时可以释放pSupportsPresent了
free(pSupportsPresent);
```


### 创建surface

```c
    VkWin32SurfaceCreateInfoKHR createInfo = {};
    createInfo.sType = VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR;
    createInfo.pNext = NULL;
    createInfo.hinstance = info.connection;
    createInfo.hwnd = info.window;
    res = vkCreateWin32SurfaceKHR(info.inst, &createInfo, NULL, &info.surface);

```