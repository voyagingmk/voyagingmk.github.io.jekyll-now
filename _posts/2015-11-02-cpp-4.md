---
layout: post_latex
title: 关于c++11的一些特性(2) 完美转发
published: true
tags: ['c++']
---

本文测试环境: 

系统：Linux ubuntu 4.2.0-16-generic #19-Ubuntu SMP x86_64 GNU/Linux

gcc版本: gcc version 5.2.1 20151010 (Ubuntu 5.2.1-22ubuntu2)

<!--more-->

# 神奇的emplace_back函数

使用std::vector时，要么存储的是指针类型，要么是值类型。指针类型是指，我把一个对象放在别的地方，比如说堆内存，然后把这个对象的内存地址放在vector里；值类型是值，我不把对象放别的地方了，而是直接放到vector自己的内存空间里。

对于值类型的情况，要考虑一个问题：往vector插入对象，这个操作可能开销会很大。

比如看下面这段测试代码:

{% highlight cpp linenos %}

#include <stdio.h>
#include <vector>
using namespace std;


class Item {
public:
    char name;
    int val;
public:
    ~Item() {
        printf("[dtor called] (%c, %i)\n", name, val);
    }
    Item() :name('_'), val(0) {
        printf("[default ctor called] \n");
    }

    Item(char n, int v) :name(n), val(v) {
        printf("[ctor called] (%c, %i)\n", name, val);
    }
    Item(Item&& a) {
        printf("[move ctor called] (%c, %i)\n", a.name, a.val);
        name = a.name;
        val = a.val;
    }
};


int main() {
    vector<Item> v1;
    for (int i = 0; i < 3; i++) {
        v1.emplace_back('a', i);
    }
    printf("-----------------------\n");
    vector<Item> v2;
    v2.reserve(10);
    for (int i = 0; i < 3; i++) {
        v2.emplace_back('b', i);
    }
    printf("-----------------------\n");
    vector<Item> v3;
    v3.push_back({ 'c', 3 });
    printf("-----------------------\n");
    return 0;
}
{% endhighlight %}

编译:

gcc test.cpp -o test.out -std=gnu++11 -lstdc++

运行结果：

{% highlight cpp linenos %}
[ctor called] (a, 0)
[move ctor called] (a, 0)
[dtor called] (a, 0)
[ctor called] (a, 1)
[move ctor called] (a, 0)
[move ctor called] (a, 1)
[dtor called] (a, 0)
[dtor called] (a, 1)
[ctor called] (a, 2)
-----------------------
[ctor called] (b, 0)
[ctor called] (b, 1)
[ctor called] (b, 2)
-----------------------
[ctor called] (c, 3)
[move ctor called] (c, 3)
[dtor called] (c, 3)
-----------------------
[dtor called] (c, 3)
[dtor called] (b, 0)
[dtor called] (b, 1)
[dtor called] (b, 2)
[dtor called] (a, 0)
[dtor called] (a, 1)
[dtor called] (a, 2)

{% endhighlight %}


观察发现：

- 第一段测试，有多余的函数调用：move构造函数以及析构函数
- 第二段测试，没有多余的调用
- 第三段测试，有多余的函数调用：move构造函数以及析构函数

所以第二种写法是性能最好的。能够直接在vector的内存空间中构造对象。其他写法都会生成临时对象。

然而实际编程中，并不是总能这样子写，因为reverse的参数该填多少，需要细心考虑；如果vector存的是基类指针类型，那么上面任意一种写法差别都不大(最多拷贝一个指针地址而已)。

这些问题另当别论，现在回到本文主题上。

这个例子中的：v2.emplace_back('b', i)，其实就是用**完美转发**实现的。

# Imperfect forwarding

理解完美转发之前，先搞懂什么是不完美转发。下面会用一些测试代码来分析一下。

前置说明:

func是随便写的一个普通函数；wrapper是对func的一层封装；测试过程是控制变量法，针对特定的wrapper函数写法，不断修改func的参数的类型以及wrapper的调用方式，测试程序是否可以编译并且wrapper函数是否能够正确完成作为一个“封装函数”的基本要求。


### 第1组测试

{% highlight cpp linenos %}

void func(const int p) {
}

int number99(){
	return 99;
}

template <typename T1>
void wrapper(T1& p) { func(p); }

//used for switching the two test cases below
#define TEST_FUNC

#if defined(TEST_FUNC)

void test_func(){
	int a = 1;
	const int b = 1;
	int& c = a; 
	const int& d = a;
	func(a); // ok
	func(b); // ok
	func(c); // ok
	func(d); // ok
	func(1); // ok
	func(number99()); // ok
}

#else

void test_wrapper(){
	int a = 1;
	const int b = 1;
	int& c = a; 
	const int& d = a;
	wrapper(a); // ok
	wrapper(b); // ok
	wrapper(c); // ok
	wrapper(d); // ok
	wrapper(1); // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
	wrapper(number99()); // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
}

#endif

{% endhighlight %}

第1组测试，wrapper函数就和func表现得不一致了。

### 第2组测试

{% highlight cpp linenos %}

void func(int p) {
}

int number99(){
	return 99;
}

template <typename T1>
void wrapper(T1& p) { func(p); }

//used for switching the two test cases below
#define TEST_FUNC

#if defined(TEST_FUNC)

void test_func(){
	int a = 1;
	const int b = 1;
	int& c = a; 
	const int& d = a;
	func(a); // ok
	func(b); // ok
	func(c); // ok
	func(d); // ok
	func(1); // ok
	func(number99()); // ok
}

#else

void test_wrapper(){
	int a = 1;
	const int b = 1;
	int& c = a; 
	const int& d = a;
	wrapper(a); // ok
	wrapper(b); // ok
	wrapper(c); // ok
	wrapper(d); // ok
	wrapper(1); // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
	wrapper(number99()); // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
}

#endif

{% endhighlight %}

结果和第1组一样。

### 第3组测试

{% highlight cpp linenos %}

void func(int& p) {
}

int number99(){
	return 99;
}

template <typename T1>
void wrapper(T1& p) { func(p); }

#define TEST_FUNC

#if defined(TEST_FUNC)

void test_func(){
	int a = 1;
	const int b = 1;
	int& c = a; 
	const int& d = a;
	func(a); // ok
	func(b); // error: binding ‘const int’ to reference of type ‘int&’ discards qualifiers
	func(c); // ok
	func(d); // error: binding ‘const int’ to reference of type ‘int&’ discards qualifiers
	func(1); // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
	func(number99()); // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
}

#else

void test_wrapper(){
	int a = 1;
	const int b = 1;
	int& c = a; 
	const int& d = a;
	wrapper(a); // ok
	wrapper(b); // error: binding ‘const int’ to reference of type ‘int&’ discards qualifiers
	wrapper(c); // ok
	wrapper(d); // error: binding ‘const int’ to reference of type ‘int&’ discards qualifiers
	wrapper(1); // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
	wrapper(number99()); // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
}

#endif

{% endhighlight %}

这个情况，其实编译结果还是不一致的。若想知道具体细节请自己编译一遍。

### 第4组测试

{% highlight cpp linenos %}

void func(const int& p) {
}

int number99(){
	return 99;
}

template <typename T1>
void wrapper(T1& p) { func(p); }

//used for switching the two test cases below
#define TEST_FUNC

#if defined(TEST_FUNC)

void test_func(){
	int a = 1;
	const int b = 1;
	int& c = a; 
	const int& d = a;
	func(a); // ok
	func(b); // ok
	func(c); // ok
	func(d); // ok
	func(1); // ok
	func(number99()); // ok
}

#else

void test_wrapper(){
	int a = 1;
	const int b = 1;
	int& c = a; 
	const int& d = a;
	wrapper(a); // ok
	wrapper(b); // ok
	wrapper(c); // ok
	wrapper(d); // ok
	wrapper(1); // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
	wrapper(number99()); // error: invalid initialization of non-const reference of type ‘int&’ from an rvalue of type ‘int’
}

#endif

{% endhighlight %}

结果和第1、2组一样。

### 小结

测试先到这里。由测试结果可以知道，这个wrapper是失败的(第1、2、4组测试，连最基本的编译结果都不一样)。

在c++11之前，对上面的不一致问题，是用非常暴力的方式的解决的，方式就是重载出N个wrapper的函数。

比如，把上面的第1组测试的代码改成：

{% highlight cpp linenos %}

void func(const int p) {
}

int number99(){
	return 99;
}

template <typename T1>
void wrapper(T1& p) { func(p); }

/*--- a override of wrapper ---*/
template <typename T1>
void wrapper(const T1& p) { func(p); }


//used for switching the two test cases below
#define TEST_FUNC

#if defined(TEST_FUNC)

void test_func(){
	int a = 1;
	const int b = 1;
	int& c = a; 
	const int& d = a;
	func(a); // ok
	func(b); // ok
	func(c); // ok
	func(d); // ok
	func(1); // ok
	func(number99()); // ok
}

#else

void test_wrapper(){
	int a = 1;
	const int b = 1;
	int& c = a; 
	const int& d = a;
	wrapper(a); // ok
	wrapper(b); // ok
	wrapper(c); // ok
	wrapper(d); // ok
	wrapper(1); // ok
	wrapper(number99()); // ok
}

#endif

{% endhighlight %}

增加了这段代码:
```cpp
template <typename T1>
void wrapper(const T1& p) { func(p); }
```
test_wrapper就编译通过了。(只需要注意编译结果的一致性，暂且忽略运行结果的一致性)

由此可以思考一下：如果func有N个参数，每个参数都要写const和非const两个版本，那么总共要写的wrapper函数就有2的n次方个！多么可怕。

# reference deduction (collapsing)

引用推导(或引用折叠)规则，是c++11开始才有的一个说法，具体是怎么回事呢？请看下面的代码：

```c
typedef int&  lref;
typedef int&& rref;
int n = 100;
lref&  r1 = n; // type of r1 is int&
lref&& r2 = n; // type of r2 is int&
rref&  r3 = n; // type of r3 is int&
rref&& r4 = 1; // type of r4 is int&&

```
(摘自[http://en.cppreference.com/w/cpp/language/reference](http://en.cppreference.com/w/cpp/language/reference) )

我用visual studio 2015跑了下这段代码：

![1.png](../images/2015.11/1.png)

看来是没错的。

总结了下这套推导规则：

- A& & -> A&
- A& && -> A&
- A&& & -> A&
- A&& && -> A&&

(记忆方法：只要有&，结果肯定是&)

# rvalue

C++中，有一对重要的兄弟：lvalue(左值)、rvalue(右值)。如何区分？简单来说就是，具名的是左值，不具名的是右值。



# Perfect forwarding



# universal references


# 参考资料

[http://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/](http://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/)
