---
layout: post_latex
title: redis5.0源码学习笔记（2）对象实现
tags: ['redis']
published: true
---

Note：本文实际绑定的版本是branch5.0（2018-7-25）。

(更新中)

<!--more-->


## 对象是什么

上一篇文章中，介绍了redis的各种基础数据结构，实际上，那些数据结构不是直接对应到那些redis指令的，而是加了一层object层，每种object可以用特定的1种或多种基础数据结构来实现。

## 对象类型

总共有7种：

```c
/* The actual Redis Object */
#define OBJ_STRING 0    /* String object. */
#define OBJ_LIST 1      /* List object. */
#define OBJ_SET 2       /* Set object. */
#define OBJ_ZSET 3      /* Sorted set object. */
#define OBJ_HASH 4      /* Hash object. */
#define OBJ_MODULE 5    /* Module object. */
#define OBJ_STREAM 6    /* Stream object. */
```

## 对象编码

```c
#define OBJ_ENCODING_RAW 0     /* 什么数据结构都没用到 */
#define OBJ_ENCODING_INT 1     /* 整数 */
#define OBJ_ENCODING_HT 2      /* 散列表 */
#define OBJ_ENCODING_ZIPMAP 3  /* zipmap */
#define OBJ_ENCODING_LINKEDLIST 4 /* 已废弃 */
#define OBJ_ENCODING_ZIPLIST 5 /* ziplist */
#define OBJ_ENCODING_INTSET 6  /* intset */
#define OBJ_ENCODING_SKIPLIST 7  /* skiplist */
#define OBJ_ENCODING_EMBSTR 8  /* 嵌入式sds */
#define OBJ_ENCODING_QUICKLIST 9 /* 由多个ziplist组成的链表（linked list） */
#define OBJ_ENCODING_STREAM 10 /* radix tree of listpacks */
```

## 对象结构体

```c
typedef struct redisObject {
    unsigned type:4; // 上文已介绍
    unsigned encoding:4; // 上文已介绍
    unsigned lru:LRU_BITS; // 计时的
    int refcount;
    void *ptr;
} robj;
```

##  createObject

这个是最基本的创建对象接口：

```c
robj *createObject(int type, void *ptr) {
    robj *o = zmalloc(sizeof(*o));
    o->type = type;
    o->encoding = OBJ_ENCODING_RAW;
    o->ptr = ptr;
    o->refcount = 1;
    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {
        o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL; // 根据访问频率的
    } else {
        o->lru = LRU_CLOCK(); // 根据最近访问时间淘汰的，精确到分钟
    }
    return o;
}
```

蛮简单的，没啥好说。

## createRawStringObject

```c
robj *createRawStringObject(const char *ptr, size_t len) {
    return createObject(OBJ_STRING, sdsnewlen(ptr,len));
}
```

需要2次内存分配，返回一个type为OBJ_STRING、encoding为OBJ_ENCODING_RAW的sds对象。

## createEmbeddedStringObject

这个和createRawStringObject的最大区别是，只做一次内存分配：

```c
robj *o = zmalloc(sizeof(robj)+sizeof(struct sdshdr8)+len+1);
```

encoding是OBJ_ENCODING_EMBSTR。


## 对象释放

每个对象的释放都是自动的，在decrRefCount里执行，会自动根据o->type来执行不同的释放动作。

