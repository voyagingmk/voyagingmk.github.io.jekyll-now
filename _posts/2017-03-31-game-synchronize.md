---
layout: post_latex
title: 实时战斗游戏的同步问题
tags: ['game' ]
published: true
---

<!--more-->

## 前言

做了几年游戏服务端编程，目前对战斗系统、网络通信这些东西也比较熟悉了，就差一些细节问题没打通。所以下文将记录我对战斗同步算法的思考。


## 两种同步技术的对比：状态同步和帧同步

### 状态同步

状态同步算法，我自己的理解是，在联网游戏里面，通过同步所有游戏实体的**状态**信息，来同步多个客户端。以球球大作战这个游戏为例，用状态同步算法去同步的过程应该是这样子的：每个玩家的每个球都是一个游戏实体(按了分裂键后会一变多)，每个实体有自己的坐标、速度、加速度、图标等**状态信息**，每个客户端都需要有这些信息，当所有客户端再任意一个时刻，这些信息都是一致的话，那么就是完美同步。状态同步算法的目标就是通过各种手段，使得各个实体的状态信息在各个客户端一直保持**一致**或者**近似**。

具体去实现这种状态同步技术，会遇到三大问题：**网络延迟对状态信息同步的干扰问题、玩家操作体验问题、同步对象过多问题**。

假设网络环境是完美，例如延迟小于1ms（局域网游戏就做得到），玩家的任意操作对游戏实体的影响，都可以瞬时同步到其他客户端，那么对于游戏过程就没什么影响。反之，如果网络环境差(延迟大于1000ms)，那么所有客户端的同步9成9不会一致，如果是服务器本身的问题导致延迟高，那么所有客户端都会卡，如果是单个客户端的延迟高，那么这个客户端会卡，而其他客户端一般不受影响。

玩家操作体验问题，是一个可以巧妙解决的问题。这个问题要处理好，关键点在于操作响应速度。譬如，玩家点了前进键，过了0.5秒后才开始动，和瞬间就开始动，感受完全不同的。（就像打开一个网站主页，花了0.5秒还是1秒、2秒、5秒，有很大的用户体验差距）。这个问题可以细分成各种各样的小问题，对于MMORPG，最主要的问题是位置同步，必须让玩家点了前进键，就立即开始移动，同时又要保证其他客户端的‘我’和自己客户端的‘我’是一致的位置。这个问题的解决方案就是著名的位置预测和位置拉扯技术。这里就不详述了。除了控制移动之外，玩家一般还会有很多操作，但这些操作一般对延迟的忍受都比较高，例如换装、购物，1秒左右的延迟都是可以忍受住的。

状态同步还有一大问题是同步对象数量过多的问题。这个问题的产生是因为，状态同步为了同步各个客户端里各个游戏对象的状态，需要不断发送游戏对象的状态信息。先不考虑发送频率的问题，单单考虑游戏对象数量，问题就很可怕了。假设现在游戏关卡里面有10个玩家，但是每个玩家有100只宠物辅助战斗，每个宠物根据自己的AI作战，那么就是说1000个游戏实体需要同步。假设每个实体平均1秒就会发一个状态包，1000个实体的话，平均每毫秒就得发一个包。简直不可能做到。

对象数量问题，比前两个问题更难搞，一般解决方法就是在游戏设计上设限制，保持同屏的同步对象不会过多。而在技术上只能是尽量降低单个对象的同步开销，使得数量上限高一点。

## 帧同步

帧同步技术的第一个要点就是，游戏的战斗必须变成一个确定性函数系统。确定性函数系统的特征是，给定固定的输入参数，这个系统就会有固定的输出（类似hash表结构）。为了做到这一点，就必须剔除掉战斗系统的**各种不确定性因素**，例如随机数生成器必须可控，浮点数计算在不同机器上计算结果需要一致等。

除此之外，一个战斗系统，必然是支持**逐帧更新**的，这个机制就好比实时渲染系统，每秒渲染60个画面（离散），当FPS足够高时，画面看起来就是**连续**的。在支持了逐帧更新后，这个战斗系统就是我所认为的**帧逻辑系统**。

为什么大费周章地把战斗系统变成这样子呢？这是因为帧同步可以解决状态同步所不能解决的那第三个问题：游戏实体过多问题。这是因为，基于帧同步的游戏战斗系统，需要做多客户端同步的东西并不是各个实体的状态信息，而是**玩家的操作输入**。因为一个确定性函数系统，给定固定输入后，就必然会有固定的输出，那么只要保证各个客户端的战斗系统是同一个确定性函数系统，并且保证各个客户端的玩家操作（函数输入）都是一致的，那么所得到的每一逻辑帧的战斗状态就是一致的。

但可惜的是，帧同步技术依然要面临网络延迟问题和玩家操作体验问题。

基于帧逻辑系统的游戏战斗系统的设计要点：

1. 客户端-服务端都需要有战斗代码
2. 以服务端的帧逻辑系统为准，客户端依据服务端保持同步
3. 客户端之间不互相等待，避免1个客户端卡，导致所有其他客户端也卡
4. 因为第3点的存在，服务端帧逻辑系统是不等待客户端的，不管客户端状态如何，服务端一直按照固定的时间间隔迭代更新
5. 玩家的操作包不能本地立即处理，而是需要先发给服务端，服务端汇集所有客户端操作包并等待下一个关键帧，服务端到达下一个关键帧时，把汇集的操作包广播给所有客户端，客户端收到关键帧操作包后，才能继续更新帧逻辑系统
6. 因为第5点，玩家的各种操作会有延迟，延迟间隔为( 收到服务端关键帧信息包t1 - 发送操作包时刻t0)，因此理论上最大延迟值为关键帧间隔时间，这个时间越小，操作延迟越低，但关键帧发包频率就越高，网络负担就越重，反过来说，这个时间越大，操作延迟越高，而关键帧发包频率变低。


一般实时战斗游戏，延迟超过200ms就会造成对游戏体验的不良影响了，那么上述第6点的关键帧最大间隔必须小于200ms；再因为游戏一般以60FPS的频率更新画面，那么游戏逻辑的FPS的上限为60，即16ms左右能够更新一帧，就已经完美了。更优秀的做法是，把逻辑更新


关键点：

1. 玩家对自己的角色的操作，必须实时响应
2. 其他玩家的角色的操作包，需要尽可能快地发给自己，并播放出来
3. 非玩家控制角色，根据帧逻辑系统迭代更新，例如怪物的移动、攻击
4. 玩家角色的关键判定，必须以帧逻辑系统为主，比如玩家的扣血、死亡、技能施放等

问题：

1. 基于帧同步算法，怎么做位置预测？服务端慢于客户端，其他客户端又慢于服务端，怎么实现多端的实时帧同步？

原则上，客户端的移动操作必须尽可能快地发给其他客户端（想象下，如果A突然往B方向开始移动，因为网络延迟，1秒后B的屏幕上的A才开始移动，而这1秒内A可能已经走到B的身边对A发起攻击了，B相当吃亏)。那么，完全基于帧同步算法的话，



2. 尽可能相信客户端的移动操作。这是因为，假设A在t0时刻向前移动，服务端在t1时刻收到A的移动操作包时，A实际上已经以速度v移动了v*(t1 -t0)的距离，服务端可以根据A的速度v和时间差t1-t0，直接把A挪到新位置，这样就同步了客户端A和服务端A；剩下的问题就是同步服务端和其他客户端，仍然使用这个同步方法，服务端把A的移动包广播到其他客户端，其他客户端根据时间差，判定A的新位置，并使用仔细设计过的缓动逻辑，把A挪到新位置，然后继续同步。

问题是，在帧同步算法里面，怎么融合这种位置同步呢？

3. 除了位置同步，其他同步完全按照帧同步算法做。把位置同步单独特殊处理，能在不增加复杂度的前提下，提升体验。

4. 除了移动操作之外的玩家操作，因为需要以帧系统为主，所以必须忍受一定时间的延迟，