---
layout: post_latex
title: 实时战斗游戏的同步——问题分析
tags: ['game' ]
published: true
---

<!--more-->

## 前言

做了几年游戏服务端编程，目前对战斗系统、网络通信这些东西也比较熟悉了，就差一些细节问题没打通。所以下文将记录我对战斗同步算法的思考。


## 两种同步技术的对比：状态同步和帧同步

### 状态同步

状态同步算法，我自己的理解是，在联网游戏里面，通过同步所有游戏实体的**状态**信息，来同步多个客户端。以球球大作战这个游戏为例，用状态同步算法去同步的过程应该是这样子的：每个玩家的每个球都是一个游戏实体(按了分裂键后会一变多)，每个实体有自己的坐标、速度、加速度、图标等**状态信息**，每个客户端都需要有这些信息，当所有客户端再任意一个时刻，这些信息都是一致的话，那么就是完美同步。状态同步算法的目标就是通过各种手段，使得各个实体的状态信息在各个客户端一直保持**一致**或者**近似**。

具体去实现这种状态同步技术，会遇到三大问题：**网络延迟对状态信息同步的干扰问题、玩家操作体验问题、同步对象过多问题**。

假设网络环境是完美，例如延迟小于1ms（局域网游戏就做得到），玩家的任意操作对游戏实体的影响，都可以瞬时同步到其他客户端，那么对于游戏过程就没什么影响。反之，如果网络环境差(延迟大于1000ms)，那么所有客户端的同步9成9不会一致，如果是服务器本身的问题导致延迟高，那么所有客户端都会卡，如果是单个客户端的延迟高，那么这个客户端会卡，而其他客户端一般不受影响。

玩家操作体验问题，是一个可以巧妙解决的问题。这个问题要处理好，关键点在于操作响应速度。譬如，玩家点了前进键，过了0.5秒后才开始动，和瞬间就开始动，感受完全不同的。（就像打开一个网站主页，花了0.5秒还是1秒、2秒、5秒，有很大的用户体验差距）。这个问题可以细分成各种各样的小问题，对于MMORPG，最主要的问题是位置同步，必须让玩家点了前进键，就立即开始移动，同时又要保证其他客户端的‘我’和自己客户端的‘我’是一致的位置。这个问题的解决方案就是著名的位置预测和位置拉扯技术。这里就不详述了。除了控制移动之外，玩家一般还会有很多操作，但这些操作一般对延迟的忍受都比较高，例如换装、购物，1秒左右的延迟都是可以忍受住的。

状态同步还有一大问题是同步对象数量过多的问题。这个问题的产生是因为，状态同步为了同步各个客户端里各个游戏对象的状态，需要不断发送游戏对象的状态信息。先不考虑发送频率的问题，单单考虑游戏对象数量，问题就很可怕了。假设现在游戏关卡里面有10个玩家，但是每个玩家有100只宠物辅助战斗，每个宠物根据自己的AI作战，那么就是说1000个游戏实体需要同步。假设每个实体平均1秒就会发一个状态包，1000个实体的话，平均每毫秒就得发一个包。简直不可能做到。

对象数量问题，比前两个问题更难搞，一般解决方法就是在游戏设计上设限制，保持同屏的同步对象不会过多。而在技术上只能是尽量降低单个对象的同步开销，使得数量上限高一点。

## 帧同步

帧同步技术的第一个要点就是，游戏的战斗必须变成一个确定性函数系统。确定性函数系统的特征是，给定固定的输入参数，这个系统就会有固定的输出（类似hash表结构）。为了做到这一点，就必须剔除掉战斗系统的**各种不确定性因素**，例如随机数生成器必须可控，浮点数计算在不同机器上计算结果需要一致等。

除此之外，一个战斗系统，必然是支持**逐帧更新**的，这个机制就好比实时渲染系统，每秒渲染60个画面（离散），当FPS足够高时，画面看起来就是**连续**的。在支持了逐帧更新后，这个战斗系统就是我所认为的**帧逻辑系统**。

为什么大费周章地把战斗系统变成这样子呢？这是因为帧同步可以解决状态同步所不能解决的那第三个问题：游戏实体过多问题。这是因为，基于帧同步的游戏战斗系统，需要做多客户端同步的东西并不是各个实体的状态信息，而是**玩家的操作输入**。因为一个确定性函数系统，给定固定输入后，就必然会有固定的输出，那么只要保证各个客户端的战斗系统是同一个确定性函数系统，并且保证各个客户端的玩家操作（函数输入）都是一致的，那么所得到的每一逻辑帧的战斗状态就是一致的。

但可惜的是，帧同步技术依然要面临网络延迟问题和玩家操作体验问题。

基于帧逻辑系统的游戏战斗系统的设计要点：

1. 客户端-服务端都需要有战斗代码
2. 以服务端的帧逻辑系统为准，客户端依据服务端保持同步
3. 客户端之间不互相等待，避免1个客户端卡，导致所有其他客户端也卡
4. 因为第3点的存在，服务端帧逻辑系统是不等待客户端的，不管客户端状态如何，服务端一直按照固定的时间间隔迭代更新
5. 玩家的操作包不能本地立即处理，而是需要先发给服务端，服务端汇集所有客户端操作包并等待下一个关键帧，服务端到达下一个关键帧时，把汇集的操作包广播给所有客户端，客户端收到关键帧操作包后，才能继续更新帧逻辑系统，没有收到前，客户端到达关键帧时需要暂停逻辑更新
6. 因为第5点，玩家的各种操作会有延迟，延迟间隔为( 收到服务端关键帧信息包t1 - 发送操作包时刻t0)，因此理论上最大延迟值为关键帧间隔时间，这个时间越小，操作延迟越低，但关键帧发包频率就越高，网络负担就越重，反过来说，这个时间越大，操作延迟越高，而关键帧发包频率变低。一般实时战斗游戏，延迟超过200ms就会造成对游戏体验的不良影响了，那么上关键帧最大间隔必须小于200ms
7. 非玩家控制角色，根据帧逻辑系统迭代更新，例如怪物的生成、移动、攻击、死亡等


从玩家体验角度看，帧逻辑系统需要做到：
1. 玩家对自己的角色的操作，必须实时响应
2. 其他玩家的角色的操作包，需要尽可能快地发给自己，并播放出来
4. 玩家角色的关键判定，必须以帧逻辑系统为主，比如玩家的扣血、死亡、技能施放等


### 两种同步方案的综合总结

1. 两种同步方案在实现位置同步的问题中，技术原理是大致的，都得用位置预测。

2. 两者都需要尽可能相信客户端的移动操作。这是因为，假设A在t0时刻向前移动，服务端在t1时刻收到A的移动操作包时，A实际上已经以速度v移动了v*(t1 -t0)的距离，服务端可以根据A的速度v和时间差t1-t0，直接把A挪到新位置，这样就同步了客户端A和服务端A；剩下的问题就是同步服务端和其他客户端，仍然使用这个同步方法，服务端把A的移动包广播到其他客户端，其他客户端根据时间差，判定A的新位置，并使用仔细设计过的缓动逻辑，把A快速移动新位置，然后按照A当前的速度、加速度继续更新。当然，如果相信了客户端发来的信息，就存在作弊问题，就需要在反作弊上花一点心思。

3. 帧同步方案，对于负杂的游戏逻辑都可以轻松应对，反之，状态同步的游戏逻辑一般不能太复杂，因为需要时不时地做一次全局的游戏实体信息同步校对，毕竟每个客户端的状态没有强一致性。


4. 在帧同步中，除了移动操作之外的玩家操作，因为需要以帧系统为主，所以必须忍受一定时间的延迟，最大延迟时间一般在一个关键帧周期(200ms)；而在状态同步中，玩家操作只要服务端确认OK，就可以直接执行了，而不需要等到下个关键帧才执行。

5. 帧同步方案可以为游戏带来一个额外加分，即**回放系统**。一个高效的游戏回放系统必然是基于帧同步的，例如war3的replay文件，一场一个小时的多人游戏，replay文件仅仅只有不到1MB，这里面必然只是存储了战斗初始化数据以及最重要的**所有玩家的操作输入数据**。除了war3，moba游戏如dota、王者荣耀、lol，非moba游戏如守望先锋、coc、东方project系列游戏（注意，coc和东方project比较特殊，战斗是单机战斗，不需要多端同步），都有这种帧回放系统。假如没有帧回放系统，游戏战斗过程的记录可能就只有录屏这个方案了，随便就是几百MB大小。

6. 要应用帧同步技术，前提是这个游戏的战斗是**有始有终**的。就是说，游戏要有**场次**的概念，不能像MMORPG大地图模式、minecraft那样，游戏战斗没有明确的开始和结束时间点。这样的游戏模式，也就不需要回放系统了。同时也很难看到这类游戏同屏出现大量的游戏实体————不只是人物怪物，子弹这些小实体也要算进去。

7. 为了应用帧同步方案，需要客户端和服务端都有战斗的代码，那么也就是说，这份代码一般都得是同种语言缩写，脚本语言js、python，或者native语言c++都行，就是要保持一致。基本不可能用不同的语言写出同样的战斗系统，即使你能做到，也很难保证以后维护过程不出bug，而且开发成本急剧升高。