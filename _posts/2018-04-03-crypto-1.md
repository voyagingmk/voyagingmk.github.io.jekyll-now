---
layout: post_latex
title: 漫谈网络通讯加密
tags: ['crypto']
published: true
---

<!--more-->

## 几种加密算法

### [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)) （Rivest–Shamir–Adleman)（1977年）

基于大数质因子分解问题。

### [DH](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)（Diffie-Hellman key exchange）（1976年）

密钥交换算法。

基于离散对数问题。

### [ECC](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)（Elliptic-curve cryptography） （1985年）

基于在椭圆曲线上的离散对数的求取问题。


## DH算法

### key exchange例子（ [from here](https://scotthelme.co.uk/perfect-forward-secrecy/) )：

1. Alice和Bob首先线下商量好，使用**p (prime, 质数) = 23、g (generator, 生成器) = 5**作为通讯基础（p和g不需要绝对的保密，泄露了也没事）
2. 每次Alice和Bob想要建立通讯(连接)时，Alice自己随机生成一个在范围[1, p - 1]的数：a = 6
3. 同样，Bob自己也随机一个：b = 15
4. Alice计算： \\( A = ( g\^\{a\} ) \% p = ( 5\^\{6\} ) \% 23 =  15625 \% 23 = 8 \\)，把A发给Bob
5. Bob计算： \\( B = ( g\^\{b\} ) \% p = ( 5\^\{15\} ) \% 23 =  30517578125 \% 23 = 19 \\)，把B发给Alice
6. Alice收到B后，可计算出**对称密钥**：\\( s\_\{Alice\} = ( B\^\{a\} ) \% p = ( 19\^\{6\} ) \% 23 = 47045881 \% 23 = 2 \\)
7. Bob收到A后，可计算出**对称密钥**：\\( s\_\{Bob\} = ( A\^\{b\} ) \% p = ( 8\^\{15\} ) \% 23 = 35184372088832 \% 23 = 2 \\)

### 数学原理

其中，用到了**模幂运算**的基本定理，对于任意自然数a、b、n，有：

\\[ ab\  \%\  n =  ( ab\ \%\  n) \  \%\  n =  ( (a\ \%\  n)  (b\ \%\  n) ) \ \%\  n \\]

应用到幂运算：

\\[ a\^\{b\}\  \%\  n =  ( a \\cdots  a ) \  \%\  n =  ( (a\ \%\  n) \\cdots  (a\ \%\  n) ) \  \%\  n =  ( \ (a\ \%\  n)  \^\{b\}\  ) \ \%\  n \\]

于是有：

\\[ s\_\{Alice\} = ( B\^\{a\} ) \% p =  (\  (\  g\^\{b\} ) \% p\  ) \^\{a\}\   ) \% p =   (  \ g \% p\  ) \^\{ab\} \  ) \% p =  \ g \^\{ab\} \% p \\]

同理：

\\[ s\_\{Bob\} = ( A\^\{b\} ) \% p =  (\  (\  g\^\{a\} ) \% p\  ) \^\{b\}\   ) \% p =   (  \ g \% p\  ) \^\{ab\} \  ) \% p =  \ g \^\{ab\} \% p \\]

显然：

\\[  s\_\{Alice\} = s\_\{Bob\}  \\]

这样就协商出了对称的密钥。


### 为什么可行

从攻击者角度看，攻击者最多只能获得以下信息：

- p：23
- g：5
- A：8
- B：19

攻击者目标是获得s（serect）。要计算s，就是算2条式子：

\\[ s = ( B\^\{a\} ) \% p \\]

\\[ s = ( A\^\{b\} ) \% p \\]

显然，攻击者只需要破解出a或b，就能得到s。

又因为有：

\\[ A = ( g\^\{a\} ) \% p \\]

\\[ B = ( g\^\{b\} ) \% p \\]


所以破解a或b的方法是：

\\[ a = log\_\{g\}\^\{A\} \% p \\]

\\[ b = log\_\{g\}\^\{B\} \% p \\]

这看似很简单的算术（对数运算和取模运算），其实是很难算的。目前为止没有找到一个快速计算对数的算法。


关键在于**p这个素数要足够大**，那么以现在的计算机计算速度，就很难通过A（或B）、g、p这3个参数算出a，这被称为[离散对数难题](https://en.wikipedia.org/wiki/Discrete_logarithm)。

这里需要注意，难的是**离散对数**，即有log和mod运算并且参数是整数；若单单只有log运算，是不难的。

### p、g的选取问题

涉及到了一些数论的概念：

- [最大公约数gcd](https://en.wikipedia.org/wiki/Greatest_common_divisor)
- [数论阶](https://en.wikipedia.org/wiki/Multiplicative_order)
- [原根](https://en.wikipedia.org/wiki/Primitive_root_modulo_n)

首先明确下：

- p必须是素数，且必须是大数(1024-2048bits)，算法才安全
- g不需要是素数，且不需要很大

p、g不需要自己挑选，可以直接用[rfc5114](https://tools.ietf.org/html/rfc5114)给定的值。

例如[1024-bit MODP Group with 160-bit Prime Order Subgroup](https://tools.ietf.org/html/rfc5114#section-2.1):

![3.png](../images/2018.4/3.png)

再讲下去就是深入密码学、数论了，按住不表。


## **完全前向保密** PFS(Perfect Forward Secrecy)

### 没有PFS之前：

- 如果攻击者曾经窥探并保存了用户和服务器的加密数据流，且包括被公钥加密的对称密钥
- 如果有一天攻击者通过某种办法获得了服务器私钥
- 攻击者同时拥有了：“用公钥加密的对称密钥”、“私钥”
- 攻击者用“私钥”对“用公钥加密的对称密钥”解密，获得了对称密钥
- 攻击者此时就可以用破解出来的对称密钥对已存的历史加密数据做解密

### 基于DH的PFS：

- 不再使用公钥加密对称密钥的方案
- 改为用DH密钥交换算法（key exchange），协商对称密钥，可以直接明文传输协商时需要的信息（并不怕这些信息被窃取）
- 每次会话都协商新的对称密钥
- 因为公钥私钥没有用来加密对称密钥了，所以即使服务器私钥被盗了也不会导致历史对称密钥被破解
- 即使单次会话的对称密钥被破解了，也不会影响到别的会话

### 为什么可行

关键在于，用于生成会话密钥的“数据”，根本就没通过网络发送出去。而用公钥加密的密钥，本身就是通过网络传输的。

后者显然更容易被攻击，主要获得私钥并记录了整个会话的数据流，就可以破解了。

而前者，对称密钥的协商，根本没有用到公钥私钥，经过网络的也不是什么被加密后的密钥，而只是协商信息。攻击者要想破解某次会话的内容，只能从该次会话的加密数据流入手，没有他法。

### 问题

要做到perfect，意味着每次会话都要协商密钥，意味着增加了计算开销，不然不能保证密钥的转瞬即逝性质（ephemeral）。


## 通讯的认证

认证问题是指，如何确定和自己通讯的对方不是其他假冒者？

目前有2个主要的解决方案：消息验证码（message authentication code，MAC）和数字签名（digital signature）。

### 消息验证码

前提：

1. 通讯双方需要先约定好一个密钥，称为**共享密钥**，双方都把它安全地存起来
2. 对任意长度的消息数据，用共享密钥可以计算出对应的固定长度的MAC
2. 计算MAC必须用到共享密钥，除非密钥泄露，否则第三者无法计算出MAC值

流程：

1. 协商密钥
2. 发送方对消息计算MAC值
3. 发送方把消息和MAC值都发给对方
4. 对方收到消息后，也用共享密钥计算MAC值，并与收到的MAC值比对
5. 如果2个MAC值一致，那么消息确实来自于发送方

#### 各种问题：


一，密钥协商问题（上面已提过）。


二，重放攻击(replay attack)：攻击者窃听通讯双方（例如2个银行）的数据，把汇款消息保存了下来（带有MAC值），然后重复发送这个汇款消息，接收方就会重复地向发送方发起汇款。其中，攻击者并不需要破解消息。

解决方法：每条消息都加序号，序号必须保证递增，从而每条消息的序号唯一；消息加时间戳，但时钟同步和时钟精度又是新的问题；每个消息加nonce，一个只能用一次随机数。


三，密钥推测攻击：应确保攻击者不能通过MAC值逆向出共享密钥，否则攻击者就可以伪造发包了。

四，对第三方证明问题：共享密钥只能保证2个人之间的通讯认证，但是如果多于2个人时，理论上共享密钥无法解决认证问题。

例子：用户A向银行B用共享密钥传输了一个取款消息，如果B取款前需要告知C“A申请取款”，C是否可以相信A真的发出了取款消息，还是说消息是B杜撰的？答案是C没有办法知道。

五，防止否认问题：就上面的取款例子，如果A真的发起了取款消息，但是事后又矢口否认，A认为是B杜撰了这个消息，此时事实就说不清了，A和B都有共享密钥，无法知道消息是A说的还是B说的。

### 数字签名

简单来说，数字签名是公钥加密的逆向过程。

对比一下：

- 公钥加密
    - 公钥：发送者加密时使用
    - 私钥：接收者解密时使用

- 数字签名
    - 公钥：验证者验证签名时使用
    - 私钥：签名者生成签名时使用

这里面的公钥私钥是一样的东西，只是用法不一样。私钥依然需要保密地持有，而公钥依然可以任意地公开。

为什么公钥加密反过来就是数字签名，而不是反方向的加密呢？用心琢磨下就知道了：用私钥去加密消息，而谁都能拿到公钥去解密，有什么保密意义可言？

其中还有一个关键点是由公钥的数学原理保证的：用私钥加密的消息，只能用配套的公钥才能解密。


数字签名使用方法：

1. 发送方计算消息的摘要（MD5，SHA-1）
2. 发送方对摘要用自己的私钥加密，生成数字签名
3. 发送方把消息和数字签名同时发出
4. 任何人都可以用发送方公布的公钥对数字签名解密
5. 通过对比解出来的摘要和自己算出来的摘要，就可以知道消息是不是来自发送方（识别修改）

注意，上面说的消息，可以是明文也可以是密文，也就是说数字签名支持对明文做签名。

公钥证书：

对签名用到的公钥私钥对中的公钥也进行签名，就得到了公钥证书。（是不是有一种递归的感觉。）

公钥证书可以用来判断收到的公钥是不是真的公钥。因为有可能收到假的公钥，用假公钥去做数字签名的解密就会一直失败。




## 完整的网络安全通讯设计

1. 


## 参考资料

https://scotthelme.co.uk/perfect-forward-secrecy/
