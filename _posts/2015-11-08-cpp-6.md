---
layout: post_latex
title: 《Effective Modern C++》读书笔记
published: true
tags: ['c++']
---

Note：为避免各种侵权问题，本文并没有复制原书任意内容。需要原书完整中文翻译的读者请等待官方译本的发布。


<!--more-->

# 正文

为了让本文更加清晰，依然还是用**条款**的形式来介绍知识点。(但不能保证我写的**条款**就是原书的条款)


## 条款7：考虑用新的变量初始化语法{}代替旧的()吧

### 优点：

- 用{}来初始化变量，可以避免程序员不期望的隐式类型转换(更具体地说应该是narrowing conversions，收缩转换)；
- 用{}替代()，可以避免Widget a()被编译器解析(parsed)成函数声明的问题；

### 缺点：

- 和auto结合得不友好，auto遇到{}，auto推导成了std::initializer_list，这不是所期望的；
- 当类的多个构造函数里，有一个是用std::initializer_list时，要注意其他构造函数不能用{}语法；
- 当类有类型转换函数时，第二个缺点会变得更严重：复制构造函数可能不会被调用；
- 当存在std::initializer_list构造函数时，即使构造代码不正确，编译器也不会转而使用其他构造函数来构造(即使其他构造函数更加match)，而是报错。(一种例外情况是当{...}里的元素不能被转换成std::initializer_list的T时，编译器才会转而使用其他构造函数)；

### 编写类构造函数的最佳实践

当你要给自定义的类加上std::initializer_list构造函数时，要细心考虑这个类被使用时，用{}和()是否一致，是否会有反直觉的结果。也就是说，为了避免上面所说的缺点，为了不坑自己或你的代码的用户，你需要在编写一个class时保持警惕。如无必要，应尽可能不添加td::initializer_list构造函数。

### c++11创造了2个阵营

用()构造亦或用{}构造对象。只使用()的话，是传统派；只使用{}的话，是革新派。革新派追求{}的那2个优点，对{}的缺点保持乐观面对的态度；传统派更重视避免std::initializer_list构造函数带来的问题。选择哪一个阵营，看自己喜好了。

### 对于库的编写者，并不是立场的问题

编写template function，可能会需要构造局部变量，当局部变量的类型未知时，怎么知道要用{}还是()？万一T是一个革新派写的class，而你又用了{}来构造对象，那么你的template function的执行情况，可能和T的构造函数重载情况大有关系。也即是说，你的template function是不稳定的。究竟在template function里用{}还是()，是一个复杂的问题。


## 条款8：不用考虑了，就用nullptr代替0和NULL

nullptr的好处在哪，请阅读书中的例子。这个条款十分简单：不要再用0和NULL来表示空指针，而是用c++11的nullptr，只有好处，没有坏处。
