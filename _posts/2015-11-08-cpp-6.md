---
layout: post_latex
title: 《Effective Modern C++》读书笔记
published: true
tags: ['c++']
---

Note：为避免各种侵权问题，本文并没有复制原书任意文字(代码除外，作者已经声明代码可以被使用)。需要原书完整中文翻译的读者请等待官方译本的发布。


<!--more-->

# 正文

为了让本文更加清晰，依然还是用**条款**的形式来介绍知识点。(但不能保证我写的**条款**就是原书的条款)


## 条款7：考虑用新的变量初始化语法{}代替旧的()吧

### 优点：

- 用{}来初始化变量，可以避免程序员不期望的隐式类型转换(更具体地说应该是narrowing conversions，收缩转换)；
- 用{}替代()，可以避免Widget a()被编译器解析(parsed)成函数声明的问题；

### 缺点：

- 和auto结合得不友好，auto遇到{}，auto推导成了std::initializer_list，这不是所期望的；
- 当类的多个构造函数里，有一个是用std::initializer_list时，要注意其他构造函数不能用{}语法；
- 当类有类型转换函数时，第二个缺点会变得更严重：复制构造函数可能不会被调用；
- 当存在std::initializer_list构造函数时，即使构造代码不正确，编译器也不会转而使用其他构造函数来构造(即使其他构造函数更加match)，而是报错。(一种例外情况是当{...}里的元素不能被转换成std::initializer_list的T时，编译器才会转而使用其他构造函数)；

### 编写类构造函数的最佳实践

当你要给自定义的类加上std::initializer_list构造函数时，要细心考虑这个类被使用时，用{}和()是否一致，是否会有反直觉的结果。也就是说，为了避免上面所说的缺点，为了不坑自己或你的代码的用户，你需要在编写一个class时保持警惕。如无必要，应尽可能不添加td::initializer_list构造函数。

### c++11创造了2个阵营

用()构造亦或用{}构造对象。只使用()的话，是传统派；只使用{}的话，是革新派。革新派追求{}的那2个优点，对{}的缺点保持乐观面对的态度；传统派更重视避免std::initializer_list构造函数带来的问题。选择哪一个阵营，看自己喜好了。

### 对于库的编写者，并不是立场的问题

编写template function，可能会需要构造局部变量，当局部变量的类型未知时，怎么知道要用{}还是()？万一T是一个革新派写的class，而你又用了{}来构造对象，那么你的template function的执行情况，可能和T的构造函数重载情况大有关系。也即是说，你的template function是不稳定的。究竟在template function里用{}还是()，是一个复杂的问题。


## 条款8：不用考虑了，就用nullptr代替0和NULL

nullptr的好处在哪，请阅读书中的例子。这个条款十分简单：不要再用0和NULL来表示空指针，而是用c++11的nullptr，只有好处，没有坏处。


## 条款9：用using代替typedef

同条款8，大部分情况下都可以用using代替typedef。

## 条款10：具有作用域的enum

写法如下:

```cpp

enum class Color { black, white, red }; // black, white, red
// are scoped to Color
auto white = false; // fine, no othe
Color c = white; // error! no enumerator named
// "white" is in this scope
Color c = Color::white; // fine
auto c = Color::white; // also fine (and in accord
// with Item 5's advice)

```

我觉得主要好处是避免名空间污染。


c++11还允许给enum指定underlying type：

```cpp

enum class Status: std::uint32_t; // underlying type for
// Status is std::uint32_t
// (from <cstdint>)

```

意思是，Status的每一个元素都是std::uint32_t类型。缺省类型是int。

还有就是，c++11 enum支持前置声明(类似class的前置声明)。




## 条款10：新功能：在成员函数声明后面加 = delete

这样子写:

```cpp

class A {
public:
    A(const A& ) = delete;
    A& operator=(const A&) = delete;
};
```

想比c++98的做法(把函数声明为private，并不定义实现)：

```cpp

class A {
private:
    A(const A& );
    A& operator=(const A&);
};
```

用 = delete会更好，因为被声明 = delete的函数，编译器保证什么代码都不能调用它们(会编译报错)，如果是c++98，有可能是链接时才报错。

注意到 = delete声明的函数，是public的，其实是为了让报错内容更准确。想一下，如果 = delete的函数是private，然后这个函数被外部调用，编译器可能只是给出"不能调用private函数"的错误信息。这可能会误导调用者。

= delete的另一个特性是，它并不是只能用在类成员函数，而是任意函数。看这段代码:


```cpp


bool isLucky(int number); // original function
bool isLucky(char) = delete; // reject chars
bool isLucky(bool) = delete; // reject bools
bool isLucky(double) = delete; // reject doubles and floats

if (isLucky('a')) … // error! call to deleted function
if (isLucky(true)) … // error!
if (isLucky(3.5f)) … // error!

```

把后3个函数重载给delete掉，保证了那3种调用方式不能被编译！也就是说，=delete可以用来阻止隐式转换陷阱。

用= delete还有一个高端的好处：在class内部的函数模板，它的访问类型只能是public、protected、private其中一种，不能又有public又有private的实例化，所以c++98的"delete"方案对函数模板没辙。还好，C++11解决了这个问题，用= delete即可：

```cpp

class A {
public:
    template<typename T>
    void foo(T* ptr) { }

};

template<>
void A::foo<void>(void*) = delete; // still public, but deleted

```

再引用下作者的一段话:

> the C++98 approach is not as good as the real thing. It doesn’t work outside classes, it doesn’t always work inside classes, and when it does work, it may not work until link-time. So stick to deleted functions.

