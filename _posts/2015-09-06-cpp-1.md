---
layout: post
title: More Effective C++ 笔记
published: true
tags: ['c++']
---

## 基础议题(basics)

### 条款1：仔细区别pointers和references

- 使用引用，可以不做null判断
- 当需要考虑“不指向任何对象”的可能性时，或是考虑“在不同时间指向不同对象”的能力时，你就应该采用pointer，前一种情况可以将pointer设为null，后一种情况可以改变pointer所指对象。
- 当确定“总是会代表某个对象”，而且“一旦代表了该对象就不能够再改变”，那么应该选用reference。
- 总是令operator[]返回一个reference。

### 条款2：最好使用C++转型操作符

- 需要使用类型转换时，先考虑能不能用static_cast
- 不能用static_cast的情况有：
	- 移除表达式的常量性(constness)或变易性(volatileness) [用const_cast]
	- 继承体系的转型 [用dynamic_cast]
- const_cast无法进行继承体系的向下转型(cast down)
- dynamic_cast无法用在缺乏虚函数的类型身上，也不能改变常量性
- reinterpret_cast不具移植性，是平台相关的

### 条款3：绝对不要以多态(polymorphically)方式处理数组

```c
void printBSTArray(ostream& s, const BST array[], int numElements)
{
	for(int i =0; i < numElements;i++){
		s<<array[i];
	}
}
BST BSTArray[10];
BalanceBST bBSTArray[10];
printBSTArray(cout, BSTArray,10);//OK
printBSTArray(cout, bBSTArray,10);//Not OK
```
array[i]其实是一个“指针算术表达式”的简写；它代表的其实是* (array+i)。array所指内存和array+i所指内存的距离是i*sizeof(数组中的单个元素)。而因为printBSTArray中，声明了array的元素的类型为BST，所以距离是i*sizeof(BST)。但当传入的是BalanceBST的数组时，就会出错了。

在删除数组时，也有这个问题，C++语言规范中说，通过base class指针删除一个由derived classes objects构成的数组，其结果未定义。

总的一句话：多态和指针算术不能混用，数组对象几乎总是会涉及指针的算法运算，所以数组和多态不要混用。

### 条款4：非必要不提供 default constructor

- 有default constructor时，可以避免3个问题，一是类数组的初始化不支持带参数的构造函数，二是一些c++模板库，要求被实例化的目标类型必须要有default constructor，三是类的虚继承体系中，如果基类没有default constructor，那么每一层的子类都必须了解基类的构造函数。
- 反过来看，使用default constructor时，可能会增加了类的复杂度，因为不能保证每个字段都有意义（default constructor导致赋予字段一个缺省值，这个缺省值可能是多余的）。并且，使用这些字段的调用者，都需要做一个“测试”，测试字段是否真的被初始化了。

## 操作符(operators)

### 条款5：对定制的“类型转换函数”保持警觉

- 用一个普通函数来替代类型转换操作符。因为这种操作符重载是"隐式(implicit)"的：
```c
class Rational{
public:
operator double() const; //not good
double asDouble() const; //good
}
```

- 单自变量构造函数，前面要加一个explicit声明。
- 用proxy classes 技术时，可以使用隐式类型转换，因为不能连续执行多个类型转换行为（详情见条款30）。



### 条款6：区别 increment/decrement操作符的前置和后置形式




