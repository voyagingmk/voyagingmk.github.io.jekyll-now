---
layout: post_latex
title: 漫谈网络通讯加密
tags: ['crypto']
published: true
---

<!--more-->

## 几种加密算法

### RSA

基于大数质因子分解问题。

### ECC

基于在椭圆曲线上的离散对数的求取问题。

### DH（Diffie-Hellman）

基于离散对数问题。

## **完全前向保密** PFS(Perfect Forward Secrecy)

### 没有PFS之前：

- 如果攻击者曾经窥探并保存了用户和服务器的加密数据流，且包括被公钥加密的对称密钥
- 如果有一天攻击者通过某种办法获得了服务器私钥
- 攻击者同时拥有了：“用公钥加密的对称密钥”、“私钥”
- 攻击者用“私钥”对“用公钥加密的对称密钥”解密，获得了对称密钥
- 攻击者此时就可以用破解出来的对称密钥对已存的历史加密数据做解密

### 基于DH的PFS：

- 不再使用公钥加密对称密钥的方案
- 改为用DH密钥交换算法（key exchange），协商对称密钥，可以直接明文传输协商时需要的信息（并不怕对称密钥被破解）
- 每次会话都协商新的对称密钥
- 因为公钥私钥没有用来加密对称密钥了，所以即使服务器私钥被盗了也不会导致历史对称密钥被破解
- 即使单次会话的对称密钥被破解了，也不会影响到别的会话


### key exchange例子（ [from here](https://scotthelme.co.uk/perfect-forward-secrecy/) )：

1. Alice和Bob首先线下商量好，使用**质数p = 23、基数g = 5**作为通讯基础
2. Alice自己随机选择一个数字：a = 6
3. Bob自己随机选择一个数字：b = 15
4. Alice计算： \\( A = ( g\^\{a\} ) \% p = ( 5\^\{6\} ) \% 23 =  15625 \% 23 = 8 \\)，把A发给Bob
5. Bob计算： \\( B = ( g\^\{b\} ) \% p = ( 5\^\{15\} ) \% 23 =  30517578125 \% 23 = 19 \\)，把B发给Alice
6. Alice收到B后，可计算出**对称密钥**：\\( s = B\^\{a\} \% p = ( 19\^\{6\} ) \% 23 = 47045881 \% 23 = 2 \\)
7. Bob收到A后，可计算出**对称密钥**：\\( s = A\^\{b\} \% p = ( 8\^\{15\} ) \% 23 = 35184372088832 \% 23 = 2 \\)
